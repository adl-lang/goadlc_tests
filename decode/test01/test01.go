// Code generated by goadlc v3 - DO NOT EDIT.
package test01

import (
	"fmt"
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/adljson"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
)

type A int64

type B struct {
	A int64 `json:"a"`
}

func New_B(
	a int64,
) B {
	return B{
		A: a,
	}
}

func Make_B(
	a int64,
) B {
	ret := B{
		A: a,
	}
	return ret
}

type Bool struct {
	A bool `json:"a"`
}

func New_Bool(
	a bool,
) Bool {
	return Bool{
		A: a,
	}
}

func Make_Bool(
	a bool,
) Bool {
	ret := Bool{
		A: a,
	}
	return ret
}

type C struct {
	B B `json:"b"`
	C B `json:"c"`
}

func New_C(
	b B,
	c B,
) C {
	return C{
		B: b,
		C: c,
	}
}

func Make_C(
	b B,
	c B,
) C {
	ret := C{
		B: b,
		C: c,
	}
	return ret
}

type D struct {
	Branch DBranch
}

type DBranch interface {
	isDBranch()
}

func (*D) MakeNewBranch(key string) (any, error) {
	switch key {
	case "a":
		return &D_A{}, nil
	case "b":
		return &D_B{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type D_A struct {
	V int64 `branch:"a"`
}
type D_B struct {
	V B `branch:"b"`
}

func (D_A) isDBranch() {}
func (D_B) isDBranch() {}

func Make_D_a(v int64) D {
	return D{
		D_A{v},
	}
}

func Make_D_b(v B) D {
	return D{
		D_B{v},
	}
}

func Handle_D[T any](
	_in DBranch,
	a func(a int64) T,
	b func(b B) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case D_A:
		if a != nil {
			return a(_b.V)
		}
	case D_B:
		if b != nil {
			return b(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : D")
}

func HandleWithErr_D[T any](
	_in DBranch,
	a func(a int64) (T, error),
	b func(b B) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case D_A:
		if a != nil {
			return a(_b.V)
		}
	case D_B:
		if b != nil {
			return b(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : D")
}

type E struct {
	D D `json:"d"`
}

func New_E(
	d D,
) E {
	return E{
		D: d,
	}
}

func Make_E(
	d D,
) E {
	ret := E{
		D: d,
	}
	return ret
}

type F struct {
	A int8             `json:"a"`
	B int16            `json:"b"`
	C int32            `json:"c"`
	D int64            `json:"d"`
	E uint8            `json:"e"`
	F uint16           `json:"f"`
	G uint32           `json:"g"`
	H uint64           `json:"h"`
	I bool             `json:"i"`
	J float64          `json:"j"`
	K float64          `json:"k"`
	L string           `json:"l"`
	N any              `json:"n"`
	O []int64          `json:"o"`
	P map[string]int64 `json:"p"`
	Q *int64           `json:"q"`
	R struct{}         `json:"r"`
}

func New_F(
	a int8,
	b int16,
	c int32,
	d int64,
	e uint8,
	f uint16,
	g uint32,
	h uint64,
	i bool,
	j float64,
	k float64,
	l string,
	n any,
	o []int64,
	p map[string]int64,
	q *int64,
	r struct{},
) F {
	return F{
		A: a,
		B: b,
		C: c,
		D: d,
		E: e,
		F: f,
		G: g,
		H: h,
		I: i,
		J: j,
		K: k,
		L: l,
		N: n,
		O: o,
		P: p,
		Q: q,
		R: r,
	}
}

func Make_F(
	a int8,
	b int16,
	c int32,
	d int64,
	e uint8,
	f uint16,
	g uint32,
	h uint64,
	i bool,
	j float64,
	k float64,
	l string,
	n any,
	o []int64,
	p map[string]int64,
	q *int64,
	r struct{},
) F {
	ret := F{
		A: a,
		B: b,
		C: c,
		D: d,
		E: e,
		F: f,
		G: g,
		H: h,
		I: i,
		J: j,
		K: k,
		L: l,
		N: n,
		O: o,
		P: p,
		Q: q,
		R: r,
	}
	return ret
}

type G struct {
	A []G `json:"a"`
}

func New_G(
	a []G,
) G {
	return G{
		A: a,
	}
}

func Make_G(
	a []G,
) G {
	ret := G{
		A: a,
	}
	return ret
}

type GenericF[AA any] struct {
	A AA `json:"a"`
}

func New_GenericF[AA any](
	a AA,
) GenericF[AA] {
	return GenericF[AA]{
		A: a,
	}
}

func Make_GenericF[AA any](
	a AA,
) GenericF[AA] {
	ret := GenericF[AA]{
		A: a,
	}
	return ret
}

type HasDefault struct {
	A string `json:"a"`
}

func New_HasDefault(
	a string,
) HasDefault {
	return HasDefault{
		A: a,
	}
}

func Make_HasDefault() HasDefault {
	ret := HasDefault{
		A: ((*HasDefault)(nil)).Default_a(),
	}
	return ret
}

func (*HasDefault) Default_a() string {
	return "1234567890"
}

type Int struct {
	A int8 `json:"a"`
}

func New_Int(
	a int8,
) Int {
	return Int{
		A: a,
	}
}

func Make_Int(
	a int8,
) Int {
	ret := Int{
		A: a,
	}
	return ret
}

type Json struct {
	A any `json:"a"`
}

func New_Json(
	a any,
) Json {
	return Json{
		A: a,
	}
}

func Make_Json(
	a any,
) Json {
	ret := Json{
		A: a,
	}
	return ret
}

type MapTest struct {
	My_set customtypes.MapMap[string, int64] `json:"my_set"`
}

func New_MapTest(
	my_set customtypes.MapMap[string, int64],
) MapTest {
	return MapTest{
		My_set: my_set,
	}
}

func Make_MapTest() MapTest {
	ret := MapTest{
		My_set: ((*MapTest)(nil)).Default_my_set(),
	}
	return ret
}

func (*MapTest) Default_my_set() customtypes.MapMap[string, int64] {
	return adljson.Unwrap(((*customtypes.MapHelper)(nil)).Construct(
		&customtypes.MapMap[string, int64]{},
		[]interface{}{map[string]interface{}{"k": "a", "v": 1}},
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.TypeExpr{TypeRef: adlast.TypeRef{Branch: adlast.TypeRef_Primitive{V: "String"}}, Parameters: []adlast.TypeExpr{}},
			goadl.RESOLVER,
		).Binder(),
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.TypeExpr{TypeRef: adlast.TypeRef{Branch: adlast.TypeRef_Primitive{V: "Int64"}}, Parameters: []adlast.TypeExpr{}},
			goadl.RESOLVER,
		).Binder(),
	)).(customtypes.MapMap[string, int64])
}

type MyV[A any] []A

type NoDefault struct {
	A string `json:"a"`
}

func New_NoDefault(
	a string,
) NoDefault {
	return NoDefault{
		A: a,
	}
}

func Make_NoDefault(
	a string,
) NoDefault {
	ret := NoDefault{
		A: a,
	}
	return ret
}

type NullableString struct {
	A *string `json:"a"`
}

func New_NullableString(
	a *string,
) NullableString {
	return NullableString{
		A: a,
	}
}

func Make_NullableString(
	a *string,
) NullableString {
	ret := NullableString{
		A: a,
	}
	return ret
}

type SetTest struct {
	My_set customtypes.MapSet[string] `json:"my_set"`
}

func New_SetTest(
	my_set customtypes.MapSet[string],
) SetTest {
	return SetTest{
		My_set: my_set,
	}
}

func Make_SetTest() SetTest {
	ret := SetTest{
		My_set: ((*SetTest)(nil)).Default_my_set(),
	}
	return ret
}

func (*SetTest) Default_my_set() customtypes.MapSet[string] {
	return adljson.Unwrap(((*customtypes.SetHelper)(nil)).Construct(
		&customtypes.MapSet[string]{},
		[]interface{}{"a", "b", "z"},
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.TypeExpr{TypeRef: adlast.TypeRef{Branch: adlast.TypeRef_Primitive{V: "String"}}, Parameters: []adlast.TypeExpr{}},
			goadl.RESOLVER,
		).Binder(),
	)).(customtypes.MapSet[string])
}

type StringMapString struct {
	A map[string]string `json:"a"`
}

func New_StringMapString(
	a map[string]string,
) StringMapString {
	return StringMapString{
		A: a,
	}
}

func Make_StringMapString(
	a map[string]string,
) StringMapString {
	ret := StringMapString{
		A: a,
	}
	return ret
}

type Uint struct {
	A uint16 `json:"a"`
}

func New_Uint(
	a uint16,
) Uint {
	return Uint{
		A: a,
	}
}

func Make_Uint(
	a uint16,
) Uint {
	ret := Uint{
		A: a,
	}
	return ret
}

type Unit struct {
}

func New_Unit() Unit {
	return Unit{}
}

func Make_Unit() Unit {
	ret := Unit{}
	return ret
}

type VectorString struct {
	A []string `json:"a"`
}

func New_VectorString(
	a []string,
) VectorString {
	return VectorString{
		A: a,
	}
}

func Make_VectorString(
	a []string,
) VectorString {
	ret := VectorString{
		A: a,
	}
	return ret
}
