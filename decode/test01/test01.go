// Code generated by goadlc v3 - DO NOT EDIT.
package test01

import (
	"fmt"
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/adljson"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
)

type A int64

type B struct {
	_B
}

type _B struct {
	A int64 `json:"a"`
}

func MakeAll_B(
	a int64,
) B {
	return B{
		_B{
			A: a,
		},
	}
}

func Make_B(
	a int64,
) B {
	ret := B{
		_B{
			A: a,
		},
	}
	return ret
}

type Bool struct {
	_Bool
}

type _Bool struct {
	A bool `json:"a"`
}

func MakeAll_Bool(
	a bool,
) Bool {
	return Bool{
		_Bool{
			A: a,
		},
	}
}

func Make_Bool(
	a bool,
) Bool {
	ret := Bool{
		_Bool{
			A: a,
		},
	}
	return ret
}

type C struct {
	_C
}

type _C struct {
	B B `json:"b"`
	C B `json:"c"`
}

func MakeAll_C(
	b B,
	c B,
) C {
	return C{
		_C{
			B: b,
			C: c,
		},
	}
}

func Make_C(
	c B,
) C {
	ret := C{
		_C{
			B: ((*C)(nil)).Default_b(),
			C: c,
		},
	}
	return ret
}

func (*C) Default_b() B {
	return MakeAll_B(
		1234,
	)
}

type D struct {
	Branch DBranch
}

type DBranch interface {
	isDBranch()
}

func (*D) MakeNewBranch(key string) (any, error) {
	switch key {
	case "a":
		return &_D_A{}, nil
	case "b":
		return &_D_B{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _D_A struct {
	V int64 `branch:"a"`
}
type _D_B struct {
	V B `branch:"b"`
}

func (_D_A) isDBranch() {}
func (_D_B) isDBranch() {}

func Make_D_a(v int64) D {
	return D{
		_D_A{v},
	}
}

func Make_D_b(v B) D {
	return D{
		_D_B{v},
	}
}

func (un D) Cast_a() (int64, bool) {
	br, ok := un.Branch.(_D_A)
	return br.V, ok
}

func (un D) Cast_b() (B, bool) {
	br, ok := un.Branch.(_D_B)
	return br.V, ok
}

func Handle_D[T any](
	_in D,
	a func(a int64) T,
	b func(b B) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _D_A:
		if a != nil {
			return a(_b.V)
		}
	case _D_B:
		if b != nil {
			return b(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : D")
}

func HandleWithErr_D[T any](
	_in D,
	a func(a int64) (T, error),
	b func(b B) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _D_A:
		if a != nil {
			return a(_b.V)
		}
	case _D_B:
		if b != nil {
			return b(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : D")
}

type E struct {
	_E
}

type _E struct {
	D D `json:"d"`
}

func MakeAll_E(
	d D,
) E {
	return E{
		_E{
			D: d,
		},
	}
}

func Make_E(
	d D,
) E {
	ret := E{
		_E{
			D: d,
		},
	}
	return ret
}

type F struct {
	_F
}

type _F struct {
	A int8             `json:"a"`
	B int16            `json:"b"`
	C int32            `json:"c"`
	D int64            `json:"d"`
	E uint8            `json:"e"`
	F uint16           `json:"f"`
	G uint32           `json:"g"`
	H uint64           `json:"h"`
	I bool             `json:"i"`
	J float64          `json:"j"`
	K float64          `json:"k"`
	L string           `json:"l"`
	N any              `json:"n"`
	O []int64          `json:"o"`
	P map[string]int64 `json:"p"`
	Q *int64           `json:"q"`
	R struct{}         `json:"r"`
}

func MakeAll_F(
	a int8,
	b int16,
	c int32,
	d int64,
	e uint8,
	f uint16,
	g uint32,
	h uint64,
	i bool,
	j float64,
	k float64,
	l string,
	n any,
	o []int64,
	p map[string]int64,
	q *int64,
) F {
	return F{
		_F{
			A: a,
			B: b,
			C: c,
			D: d,
			E: e,
			F: f,
			G: g,
			H: h,
			I: i,
			J: j,
			K: k,
			L: l,
			N: n,
			O: o,
			P: p,
			Q: q,
			R: struct{}{},
		},
	}
}

func Make_F(
	a int8,
	b int16,
	c int32,
	d int64,
	e uint8,
	f uint16,
	g uint32,
	h uint64,
	i bool,
	j float64,
	k float64,
	l string,
	n any,
	o []int64,
	p map[string]int64,
	q *int64,
) F {
	ret := F{
		_F{
			A: a,
			B: b,
			C: c,
			D: d,
			E: e,
			F: f,
			G: g,
			H: h,
			I: i,
			J: j,
			K: k,
			L: l,
			N: n,
			O: o,
			P: p,
			Q: q,
			R: struct{}{},
		},
	}
	return ret
}

type G struct {
	_G
}

type _G struct {
	A []G `json:"a"`
}

func MakeAll_G(
	a []G,
) G {
	return G{
		_G{
			A: a,
		},
	}
}

func Make_G(
	a []G,
) G {
	ret := G{
		_G{
			A: a,
		},
	}
	return ret
}

type GenericF[AA any] struct {
	_GenericF[AA]
}

type _GenericF[AA any] struct {
	A AA `json:"a"`
}

func MakeAll_GenericF[AA any](
	a AA,
) GenericF[AA] {
	return GenericF[AA]{
		_GenericF[AA]{
			A: a,
		},
	}
}

func Make_GenericF[AA any](
	a AA,
) GenericF[AA] {
	ret := GenericF[AA]{
		_GenericF[AA]{
			A: a,
		},
	}
	return ret
}

type HasDefault struct {
	_HasDefault
}

type _HasDefault struct {
	A string `json:"a"`
}

func MakeAll_HasDefault(
	a string,
) HasDefault {
	return HasDefault{
		_HasDefault{
			A: a,
		},
	}
}

func Make_HasDefault() HasDefault {
	ret := HasDefault{
		_HasDefault{
			A: ((*HasDefault)(nil)).Default_a(),
		},
	}
	return ret
}

func (*HasDefault) Default_a() string {
	return "1234567890"
}

type Int struct {
	_Int
}

type _Int struct {
	A int8 `json:"a"`
}

func MakeAll_Int(
	a int8,
) Int {
	return Int{
		_Int{
			A: a,
		},
	}
}

func Make_Int(
	a int8,
) Int {
	ret := Int{
		_Int{
			A: a,
		},
	}
	return ret
}

type Json struct {
	_Json
}

type _Json struct {
	A any `json:"a"`
}

func MakeAll_Json(
	a any,
) Json {
	return Json{
		_Json{
			A: a,
		},
	}
}

func Make_Json(
	a any,
) Json {
	ret := Json{
		_Json{
			A: a,
		},
	}
	return ret
}

type MapTest struct {
	_MapTest
}

type _MapTest struct {
	My_set customtypes.MapMap[string, int64] `json:"my_set"`
}

func MakeAll_MapTest(
	my_set customtypes.MapMap[string, int64],
) MapTest {
	return MapTest{
		_MapTest{
			My_set: my_set,
		},
	}
}

func Make_MapTest() MapTest {
	ret := MapTest{
		_MapTest{
			My_set: ((*MapTest)(nil)).Default_my_set(),
		},
	}
	return ret
}

func (*MapTest) Default_my_set() customtypes.MapMap[string, int64] {
	return adljson.Unwrap(((*customtypes.MapHelper)(nil)).Construct(
		&customtypes.MapMap[string, int64]{},
		[]interface{}{map[string]interface{}{"k": "a", "v": 1}},
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.Make_TypeExpr(adlast.Make_TypeRef_primitive("String"), []adlast.TypeExpr{}),
			goadl.RESOLVER,
		).Binder(),
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.Make_TypeExpr(adlast.Make_TypeRef_primitive("Int64"), []adlast.TypeExpr{}),
			goadl.RESOLVER,
		).Binder(),
	)).(customtypes.MapMap[string, int64])
}

type MyV[A any] []A

type NoDefault struct {
	_NoDefault
}

type _NoDefault struct {
	A string `json:"a"`
}

func MakeAll_NoDefault(
	a string,
) NoDefault {
	return NoDefault{
		_NoDefault{
			A: a,
		},
	}
}

func Make_NoDefault(
	a string,
) NoDefault {
	ret := NoDefault{
		_NoDefault{
			A: a,
		},
	}
	return ret
}

type NullableString struct {
	_NullableString
}

type _NullableString struct {
	A *string `json:"a"`
}

func MakeAll_NullableString(
	a *string,
) NullableString {
	return NullableString{
		_NullableString{
			A: a,
		},
	}
}

func Make_NullableString(
	a *string,
) NullableString {
	ret := NullableString{
		_NullableString{
			A: a,
		},
	}
	return ret
}

type SetTest struct {
	_SetTest
}

type _SetTest struct {
	My_set customtypes.MapSet[string] `json:"my_set"`
}

func MakeAll_SetTest(
	my_set customtypes.MapSet[string],
) SetTest {
	return SetTest{
		_SetTest{
			My_set: my_set,
		},
	}
}

func Make_SetTest() SetTest {
	ret := SetTest{
		_SetTest{
			My_set: ((*SetTest)(nil)).Default_my_set(),
		},
	}
	return ret
}

func (*SetTest) Default_my_set() customtypes.MapSet[string] {
	return adljson.Unwrap(((*customtypes.SetHelper)(nil)).Construct(
		&customtypes.MapSet[string]{},
		[]interface{}{"a", "b", "z"},
		goadl.CreateUncheckedJsonDecodeBinding(
			adlast.Make_TypeExpr(adlast.Make_TypeRef_primitive("String"), []adlast.TypeExpr{}),
			goadl.RESOLVER,
		).Binder(),
	)).(customtypes.MapSet[string])
}

type StringMapString struct {
	_StringMapString
}

type _StringMapString struct {
	A map[string]string `json:"a"`
}

func MakeAll_StringMapString(
	a map[string]string,
) StringMapString {
	return StringMapString{
		_StringMapString{
			A: a,
		},
	}
}

func Make_StringMapString(
	a map[string]string,
) StringMapString {
	ret := StringMapString{
		_StringMapString{
			A: a,
		},
	}
	return ret
}

type Uint struct {
	_Uint
}

type _Uint struct {
	A uint16 `json:"a"`
}

func MakeAll_Uint(
	a uint16,
) Uint {
	return Uint{
		_Uint{
			A: a,
		},
	}
}

func Make_Uint(
	a uint16,
) Uint {
	ret := Uint{
		_Uint{
			A: a,
		},
	}
	return ret
}

type Unit struct {
	_Unit
}

type _Unit struct {
}

func MakeAll_Unit() Unit {
	return Unit{
		_Unit{},
	}
}

func Make_Unit() Unit {
	ret := Unit{
		_Unit{},
	}
	return ret
}

type VectorString struct {
	_VectorString
}

type _VectorString struct {
	A []string `json:"a"`
}

func MakeAll_VectorString(
	a []string,
) VectorString {
	return VectorString{
		_VectorString{
			A: a,
		},
	}
}

func Make_VectorString(
	a []string,
) VectorString {
	ret := VectorString{
		_VectorString{
			A: a,
		},
	}
	return ret
}
