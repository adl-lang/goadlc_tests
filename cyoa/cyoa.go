// Code generated by goadlc v3 - DO NOT EDIT.
package cyoa

import (
	"fmt"
)

type ChoiceThree[A any, B any, C any] struct {
	Branch ChoiceThreeBranch[A, B, C]
}

type ChoiceThreeBranch[A any, B any, C any] interface {
	isChoiceThreeBranch()
}

func (*ChoiceThree[A, B, C]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "one":
		return &ChoiceThree_One[A]{}, nil
	case "two":
		return &ChoiceThree_Two[B]{}, nil
	case "tri":
		return &ChoiceThree_Tri[C]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type ChoiceThree_One[A any] struct {
	V A `branch:"one"`
}
type ChoiceThree_Two[B any] struct {
	V B `branch:"two"`
}
type ChoiceThree_Tri[C any] struct {
	V C `branch:"tri"`
}

func (ChoiceThree_One[A]) isChoiceThreeBranch() {}
func (ChoiceThree_Two[B]) isChoiceThreeBranch() {}
func (ChoiceThree_Tri[C]) isChoiceThreeBranch() {}

func Make_ChoiceThree_one[A any, B any, C any](v A) ChoiceThree[A, B, C] {
	return ChoiceThree[A, B, C]{
		ChoiceThree_One[A]{v},
	}
}

func Make_ChoiceThree_two[A any, B any, C any](v B) ChoiceThree[A, B, C] {
	return ChoiceThree[A, B, C]{
		ChoiceThree_Two[B]{v},
	}
}

func Make_ChoiceThree_tri[A any, B any, C any](v C) ChoiceThree[A, B, C] {
	return ChoiceThree[A, B, C]{
		ChoiceThree_Tri[C]{v},
	}
}

func Handle_ChoiceThree[A any, B any, C any, T any](
	_in ChoiceThreeBranch[A, B, C],
	one func(one A) T,
	two func(two B) T,
	tri func(tri C) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case ChoiceThree_One[A]:
		if one != nil {
			return one(_b.V)
		}
	case ChoiceThree_Two[B]:
		if two != nil {
			return two(_b.V)
		}
	case ChoiceThree_Tri[C]:
		if tri != nil {
			return tri(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceThree")
}

func HandleWithErr_ChoiceThree[A any, B any, C any, T any](
	_in ChoiceThreeBranch[A, B, C],
	one func(one A) (T, error),
	two func(two B) (T, error),
	tri func(tri C) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case ChoiceThree_One[A]:
		if one != nil {
			return one(_b.V)
		}
	case ChoiceThree_Two[B]:
		if two != nil {
			return two(_b.V)
		}
	case ChoiceThree_Tri[C]:
		if tri != nil {
			return tri(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceThree")
}

type ChoiceTwo[A any, B any] struct {
	Branch ChoiceTwoBranch[A, B]
}

type ChoiceTwoBranch[A any, B any] interface {
	isChoiceTwoBranch()
}

func (*ChoiceTwo[A, B]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "one":
		return &ChoiceTwo_One[A]{}, nil
	case "two":
		return &ChoiceTwo_Two[B]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type ChoiceTwo_One[A any] struct {
	V A `branch:"one"`
}
type ChoiceTwo_Two[B any] struct {
	V B `branch:"two"`
}

func (ChoiceTwo_One[A]) isChoiceTwoBranch() {}
func (ChoiceTwo_Two[B]) isChoiceTwoBranch() {}

func Make_ChoiceTwo_one[A any, B any](v A) ChoiceTwo[A, B] {
	return ChoiceTwo[A, B]{
		ChoiceTwo_One[A]{v},
	}
}

func Make_ChoiceTwo_two[A any, B any](v B) ChoiceTwo[A, B] {
	return ChoiceTwo[A, B]{
		ChoiceTwo_Two[B]{v},
	}
}

func Handle_ChoiceTwo[A any, B any, T any](
	_in ChoiceTwoBranch[A, B],
	one func(one A) T,
	two func(two B) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case ChoiceTwo_One[A]:
		if one != nil {
			return one(_b.V)
		}
	case ChoiceTwo_Two[B]:
		if two != nil {
			return two(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceTwo")
}

func HandleWithErr_ChoiceTwo[A any, B any, T any](
	_in ChoiceTwoBranch[A, B],
	one func(one A) (T, error),
	two func(two B) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case ChoiceTwo_One[A]:
		if one != nil {
			return one(_b.V)
		}
	case ChoiceTwo_Two[B]:
		if two != nil {
			return two(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceTwo")
}

type Page[A any, B any, C any] struct {
	Branch PageBranch[A, B, C]
}

type PageBranch[A any, B any, C any] interface {
	isPageBranch()
}

func (*Page[A, B, C]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "next_page":
		return &Page_Next_page{}, nil
	case "two":
		return &Page_Two[A, B]{}, nil
	case "tri":
		return &Page_Tri[A, B, C]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type Page_Next_page struct {
	V struct{} `branch:"next_page"`
}
type Page_Two[A any, B any] struct {
	V ChoiceTwo[A, B] `branch:"two"`
}
type Page_Tri[A any, B any, C any] struct {
	V ChoiceThree[A, B, C] `branch:"tri"`
}

func (Page_Next_page) isPageBranch()    {}
func (Page_Two[A, B]) isPageBranch()    {}
func (Page_Tri[A, B, C]) isPageBranch() {}

func Make_Page_next_page[A any, B any, C any](v struct{}) Page[A, B, C] {
	return Page[A, B, C]{
		Page_Next_page{v},
	}
}

func Make_Page_two[A any, B any, C any](v ChoiceTwo[A, B]) Page[A, B, C] {
	return Page[A, B, C]{
		Page_Two[A, B]{v},
	}
}

func Make_Page_tri[A any, B any, C any](v ChoiceThree[A, B, C]) Page[A, B, C] {
	return Page[A, B, C]{
		Page_Tri[A, B, C]{v},
	}
}

func Handle_Page[A any, B any, C any, T any](
	_in PageBranch[A, B, C],
	next_page func(next_page struct{}) T,
	two func(two ChoiceTwo[A, B]) T,
	tri func(tri ChoiceThree[A, B, C]) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case Page_Next_page:
		if next_page != nil {
			return next_page(_b.V)
		}
	case Page_Two[A, B]:
		if two != nil {
			return two(_b.V)
		}
	case Page_Tri[A, B, C]:
		if tri != nil {
			return tri(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Page")
}

func HandleWithErr_Page[A any, B any, C any, T any](
	_in PageBranch[A, B, C],
	next_page func(next_page struct{}) (T, error),
	two func(two ChoiceTwo[A, B]) (T, error),
	tri func(tri ChoiceThree[A, B, C]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case Page_Next_page:
		if next_page != nil {
			return next_page(_b.V)
		}
	case Page_Two[A, B]:
		if two != nil {
			return two(_b.V)
		}
	case Page_Tri[A, B, C]:
		if tri != nil {
			return tri(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Page")
}
