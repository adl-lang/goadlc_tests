// Code generated by goadlc v3 - DO NOT EDIT.
package simple_union

import (
	"fmt"
)

type UnionOfPrimitives struct {
	Branch UnionOfPrimitivesBranch
}

type UnionOfPrimitivesBranch interface {
	isUnionOfPrimitivesBranch()
}

func (*UnionOfPrimitives) MakeNewBranch(key string) (any, error) {
	switch key {
	case "A":
		return &_UnionOfPrimitives_A{}, nil
	case "B":
		return &_UnionOfPrimitives_B{}, nil
	case "c":
		return &_UnionOfPrimitives_C{}, nil
	case "d":
		return &_UnionOfPrimitives_D{}, nil
	case "e":
		return &_UnionOfPrimitives_E{}, nil
	case "f":
		return &_UnionOfPrimitives_F{}, nil
	case "g":
		return &_UnionOfPrimitives_G{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _UnionOfPrimitives_A struct {
	V int32 `branch:"A"`
}
type _UnionOfPrimitives_B struct {
	V int64 `branch:"B"`
}
type _UnionOfPrimitives_C struct {
	V bool `branch:"c"`
}
type _UnionOfPrimitives_D struct {
	V float64 `branch:"d"`
}
type _UnionOfPrimitives_E struct {
	V string `branch:"e"`
}
type _UnionOfPrimitives_F struct {
	V []string `branch:"f"`
}
type _UnionOfPrimitives_G struct {
	V struct{} `branch:"g"`
}

func (_UnionOfPrimitives_A) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_B) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_C) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_D) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_E) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_F) isUnionOfPrimitivesBranch() {}
func (_UnionOfPrimitives_G) isUnionOfPrimitivesBranch() {}

func Make_UnionOfPrimitives_A(v int32) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_A{v},
	}
}

func Make_UnionOfPrimitives_B(v int64) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_B{v},
	}
}

func Make_UnionOfPrimitives_c(v bool) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_C{v},
	}
}

func Make_UnionOfPrimitives_d(v float64) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_D{v},
	}
}

func Make_UnionOfPrimitives_e(v string) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_E{v},
	}
}

func Make_UnionOfPrimitives_f(v []string) UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_F{v},
	}
}

func Make_UnionOfPrimitives_g() UnionOfPrimitives {
	return UnionOfPrimitives{
		_UnionOfPrimitives_G{struct{}{}},
	}
}

func (un UnionOfPrimitives) Cast_A() (int32, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_A)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_B() (int64, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_B)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_c() (bool, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_C)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_d() (float64, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_D)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_e() (string, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_E)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_f() ([]string, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_F)
	return br.V, ok
}

func (un UnionOfPrimitives) Cast_g() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfPrimitives_G)
	return br.V, ok
}

func Handle_UnionOfPrimitives[T any](
	_in UnionOfPrimitives,
	A func(A int32) T,
	B func(B int64) T,
	c func(c bool) T,
	d func(d float64) T,
	e func(e string) T,
	f func(f []string) T,
	g func(g struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _UnionOfPrimitives_A:
		if A != nil {
			return A(_b.V)
		}
	case _UnionOfPrimitives_B:
		if B != nil {
			return B(_b.V)
		}
	case _UnionOfPrimitives_C:
		if c != nil {
			return c(_b.V)
		}
	case _UnionOfPrimitives_D:
		if d != nil {
			return d(_b.V)
		}
	case _UnionOfPrimitives_E:
		if e != nil {
			return e(_b.V)
		}
	case _UnionOfPrimitives_F:
		if f != nil {
			return f(_b.V)
		}
	case _UnionOfPrimitives_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfPrimitives")
}

func HandleWithErr_UnionOfPrimitives[T any](
	_in UnionOfPrimitives,
	A func(A int32) (T, error),
	B func(B int64) (T, error),
	c func(c bool) (T, error),
	d func(d float64) (T, error),
	e func(e string) (T, error),
	f func(f []string) (T, error),
	g func(g struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _UnionOfPrimitives_A:
		if A != nil {
			return A(_b.V)
		}
	case _UnionOfPrimitives_B:
		if B != nil {
			return B(_b.V)
		}
	case _UnionOfPrimitives_C:
		if c != nil {
			return c(_b.V)
		}
	case _UnionOfPrimitives_D:
		if d != nil {
			return d(_b.V)
		}
	case _UnionOfPrimitives_E:
		if e != nil {
			return e(_b.V)
		}
	case _UnionOfPrimitives_F:
		if f != nil {
			return f(_b.V)
		}
	case _UnionOfPrimitives_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfPrimitives")
}

type UnionOfVoids struct {
	Branch UnionOfVoidsBranch
}

type UnionOfVoidsBranch interface {
	isUnionOfVoidsBranch()
}

func (*UnionOfVoids) MakeNewBranch(key string) (any, error) {
	switch key {
	case "A":
		return &_UnionOfVoids_A{}, nil
	case "B":
		return &_UnionOfVoids_B{}, nil
	case "c":
		return &_UnionOfVoids_C{}, nil
	case "d":
		return &_UnionOfVoids_D{}, nil
	case "e":
		return &_UnionOfVoids_E{}, nil
	case "f":
		return &_UnionOfVoids_F{}, nil
	case "g":
		return &_UnionOfVoids_G{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _UnionOfVoids_A struct {
	V struct{} `branch:"A"`
}
type _UnionOfVoids_B struct {
	V struct{} `branch:"B"`
}
type _UnionOfVoids_C struct {
	V struct{} `branch:"c"`
}
type _UnionOfVoids_D struct {
	V struct{} `branch:"d"`
}
type _UnionOfVoids_E struct {
	V struct{} `branch:"e"`
}
type _UnionOfVoids_F struct {
	V struct{} `branch:"f"`
}
type _UnionOfVoids_G struct {
	V struct{} `branch:"g"`
}

func (_UnionOfVoids_A) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_B) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_C) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_D) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_E) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_F) isUnionOfVoidsBranch() {}
func (_UnionOfVoids_G) isUnionOfVoidsBranch() {}

func Make_UnionOfVoids_A() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_A{struct{}{}},
	}
}

func Make_UnionOfVoids_B() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_B{struct{}{}},
	}
}

func Make_UnionOfVoids_c() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_C{struct{}{}},
	}
}

func Make_UnionOfVoids_d() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_D{struct{}{}},
	}
}

func Make_UnionOfVoids_e() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_E{struct{}{}},
	}
}

func Make_UnionOfVoids_f() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_F{struct{}{}},
	}
}

func Make_UnionOfVoids_g() UnionOfVoids {
	return UnionOfVoids{
		_UnionOfVoids_G{struct{}{}},
	}
}

func (un UnionOfVoids) Cast_A() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_A)
	return br.V, ok
}

func (un UnionOfVoids) Cast_B() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_B)
	return br.V, ok
}

func (un UnionOfVoids) Cast_c() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_C)
	return br.V, ok
}

func (un UnionOfVoids) Cast_d() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_D)
	return br.V, ok
}

func (un UnionOfVoids) Cast_e() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_E)
	return br.V, ok
}

func (un UnionOfVoids) Cast_f() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_F)
	return br.V, ok
}

func (un UnionOfVoids) Cast_g() (struct{}, bool) {
	br, ok := un.Branch.(_UnionOfVoids_G)
	return br.V, ok
}

func Handle_UnionOfVoids[T any](
	_in UnionOfVoids,
	A func(A struct{}) T,
	B func(B struct{}) T,
	c func(c struct{}) T,
	d func(d struct{}) T,
	e func(e struct{}) T,
	f func(f struct{}) T,
	g func(g struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _UnionOfVoids_A:
		if A != nil {
			return A(_b.V)
		}
	case _UnionOfVoids_B:
		if B != nil {
			return B(_b.V)
		}
	case _UnionOfVoids_C:
		if c != nil {
			return c(_b.V)
		}
	case _UnionOfVoids_D:
		if d != nil {
			return d(_b.V)
		}
	case _UnionOfVoids_E:
		if e != nil {
			return e(_b.V)
		}
	case _UnionOfVoids_F:
		if f != nil {
			return f(_b.V)
		}
	case _UnionOfVoids_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfVoids")
}

func HandleWithErr_UnionOfVoids[T any](
	_in UnionOfVoids,
	A func(A struct{}) (T, error),
	B func(B struct{}) (T, error),
	c func(c struct{}) (T, error),
	d func(d struct{}) (T, error),
	e func(e struct{}) (T, error),
	f func(f struct{}) (T, error),
	g func(g struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _UnionOfVoids_A:
		if A != nil {
			return A(_b.V)
		}
	case _UnionOfVoids_B:
		if B != nil {
			return B(_b.V)
		}
	case _UnionOfVoids_C:
		if c != nil {
			return c(_b.V)
		}
	case _UnionOfVoids_D:
		if d != nil {
			return d(_b.V)
		}
	case _UnionOfVoids_E:
		if e != nil {
			return e(_b.V)
		}
	case _UnionOfVoids_F:
		if f != nil {
			return f(_b.V)
		}
	case _UnionOfVoids_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfVoids")
}
