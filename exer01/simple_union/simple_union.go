// Code generated by goadlc v3 - DO NOT EDIT.
package simple_union

import (
	"fmt"
)

type UnionOfPrimitives struct {
	Branch UnionOfPrimitivesBranch
}

type UnionOfPrimitivesBranch interface {
	isUnionOfPrimitivesBranch()
}

func (*UnionOfPrimitives) MakeNewBranch(key string) (any, error) {
	switch key {
	case "A":
		return &UnionOfPrimitives_A{}, nil
	case "B":
		return &UnionOfPrimitives_B{}, nil
	case "c":
		return &UnionOfPrimitives_C{}, nil
	case "d":
		return &UnionOfPrimitives_D{}, nil
	case "e":
		return &UnionOfPrimitives_E{}, nil
	case "f":
		return &UnionOfPrimitives_F{}, nil
	case "g":
		return &UnionOfPrimitives_G{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type UnionOfPrimitives_A struct {
	V int32 `branch:"A"`
}
type UnionOfPrimitives_B struct {
	V int64 `branch:"B"`
}
type UnionOfPrimitives_C struct {
	V bool `branch:"c"`
}
type UnionOfPrimitives_D struct {
	V float64 `branch:"d"`
}
type UnionOfPrimitives_E struct {
	V string `branch:"e"`
}
type UnionOfPrimitives_F struct {
	V []string `branch:"f"`
}
type UnionOfPrimitives_G struct {
	V struct{} `branch:"g"`
}

func (UnionOfPrimitives_A) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_B) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_C) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_D) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_E) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_F) isUnionOfPrimitivesBranch() {}
func (UnionOfPrimitives_G) isUnionOfPrimitivesBranch() {}

func Make_UnionOfPrimitives_A(v int32) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_A{v},
	}
}

func Make_UnionOfPrimitives_B(v int64) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_B{v},
	}
}

func Make_UnionOfPrimitives_c(v bool) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_C{v},
	}
}

func Make_UnionOfPrimitives_d(v float64) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_D{v},
	}
}

func Make_UnionOfPrimitives_e(v string) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_E{v},
	}
}

func Make_UnionOfPrimitives_f(v []string) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_F{v},
	}
}

func Make_UnionOfPrimitives_g(v struct{}) UnionOfPrimitives {
	return UnionOfPrimitives{
		UnionOfPrimitives_G{v},
	}
}

func Handle_UnionOfPrimitives[T any](
	_in UnionOfPrimitivesBranch,
	A func(A int32) T,
	B func(B int64) T,
	c func(c bool) T,
	d func(d float64) T,
	e func(e string) T,
	f func(f []string) T,
	g func(g struct{}) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case UnionOfPrimitives_A:
		if A != nil {
			return A(_b.V)
		}
	case UnionOfPrimitives_B:
		if B != nil {
			return B(_b.V)
		}
	case UnionOfPrimitives_C:
		if c != nil {
			return c(_b.V)
		}
	case UnionOfPrimitives_D:
		if d != nil {
			return d(_b.V)
		}
	case UnionOfPrimitives_E:
		if e != nil {
			return e(_b.V)
		}
	case UnionOfPrimitives_F:
		if f != nil {
			return f(_b.V)
		}
	case UnionOfPrimitives_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfPrimitives")
}

func HandleWithErr_UnionOfPrimitives[T any](
	_in UnionOfPrimitivesBranch,
	A func(A int32) (T, error),
	B func(B int64) (T, error),
	c func(c bool) (T, error),
	d func(d float64) (T, error),
	e func(e string) (T, error),
	f func(f []string) (T, error),
	g func(g struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case UnionOfPrimitives_A:
		if A != nil {
			return A(_b.V)
		}
	case UnionOfPrimitives_B:
		if B != nil {
			return B(_b.V)
		}
	case UnionOfPrimitives_C:
		if c != nil {
			return c(_b.V)
		}
	case UnionOfPrimitives_D:
		if d != nil {
			return d(_b.V)
		}
	case UnionOfPrimitives_E:
		if e != nil {
			return e(_b.V)
		}
	case UnionOfPrimitives_F:
		if f != nil {
			return f(_b.V)
		}
	case UnionOfPrimitives_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfPrimitives")
}

type UnionOfVoids struct {
	Branch UnionOfVoidsBranch
}

type UnionOfVoidsBranch interface {
	isUnionOfVoidsBranch()
}

func (*UnionOfVoids) MakeNewBranch(key string) (any, error) {
	switch key {
	case "A":
		return &UnionOfVoids_A{}, nil
	case "B":
		return &UnionOfVoids_B{}, nil
	case "c":
		return &UnionOfVoids_C{}, nil
	case "d":
		return &UnionOfVoids_D{}, nil
	case "e":
		return &UnionOfVoids_E{}, nil
	case "f":
		return &UnionOfVoids_F{}, nil
	case "g":
		return &UnionOfVoids_G{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type UnionOfVoids_A struct {
	V struct{} `branch:"A"`
}
type UnionOfVoids_B struct {
	V struct{} `branch:"B"`
}
type UnionOfVoids_C struct {
	V struct{} `branch:"c"`
}
type UnionOfVoids_D struct {
	V struct{} `branch:"d"`
}
type UnionOfVoids_E struct {
	V struct{} `branch:"e"`
}
type UnionOfVoids_F struct {
	V struct{} `branch:"f"`
}
type UnionOfVoids_G struct {
	V struct{} `branch:"g"`
}

func (UnionOfVoids_A) isUnionOfVoidsBranch() {}
func (UnionOfVoids_B) isUnionOfVoidsBranch() {}
func (UnionOfVoids_C) isUnionOfVoidsBranch() {}
func (UnionOfVoids_D) isUnionOfVoidsBranch() {}
func (UnionOfVoids_E) isUnionOfVoidsBranch() {}
func (UnionOfVoids_F) isUnionOfVoidsBranch() {}
func (UnionOfVoids_G) isUnionOfVoidsBranch() {}

func Make_UnionOfVoids_A(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_A{v},
	}
}

func Make_UnionOfVoids_B(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_B{v},
	}
}

func Make_UnionOfVoids_c(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_C{v},
	}
}

func Make_UnionOfVoids_d(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_D{v},
	}
}

func Make_UnionOfVoids_e(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_E{v},
	}
}

func Make_UnionOfVoids_f(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_F{v},
	}
}

func Make_UnionOfVoids_g(v struct{}) UnionOfVoids {
	return UnionOfVoids{
		UnionOfVoids_G{v},
	}
}

func Handle_UnionOfVoids[T any](
	_in UnionOfVoidsBranch,
	A func(A struct{}) T,
	B func(B struct{}) T,
	c func(c struct{}) T,
	d func(d struct{}) T,
	e func(e struct{}) T,
	f func(f struct{}) T,
	g func(g struct{}) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case UnionOfVoids_A:
		if A != nil {
			return A(_b.V)
		}
	case UnionOfVoids_B:
		if B != nil {
			return B(_b.V)
		}
	case UnionOfVoids_C:
		if c != nil {
			return c(_b.V)
		}
	case UnionOfVoids_D:
		if d != nil {
			return d(_b.V)
		}
	case UnionOfVoids_E:
		if e != nil {
			return e(_b.V)
		}
	case UnionOfVoids_F:
		if f != nil {
			return f(_b.V)
		}
	case UnionOfVoids_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfVoids")
}

func HandleWithErr_UnionOfVoids[T any](
	_in UnionOfVoidsBranch,
	A func(A struct{}) (T, error),
	B func(B struct{}) (T, error),
	c func(c struct{}) (T, error),
	d func(d struct{}) (T, error),
	e func(e struct{}) (T, error),
	f func(f struct{}) (T, error),
	g func(g struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case UnionOfVoids_A:
		if A != nil {
			return A(_b.V)
		}
	case UnionOfVoids_B:
		if B != nil {
			return B(_b.V)
		}
	case UnionOfVoids_C:
		if c != nil {
			return c(_b.V)
		}
	case UnionOfVoids_D:
		if d != nil {
			return d(_b.V)
		}
	case UnionOfVoids_E:
		if e != nil {
			return e(_b.V)
		}
	case UnionOfVoids_F:
		if f != nil {
			return f(_b.V)
		}
	case UnionOfVoids_G:
		if g != nil {
			return g(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : UnionOfVoids")
}
