// Code generated by goadlc v3 - DO NOT EDIT.
package struct_with_void

import (
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

func Texpr_StructB[X any](x adlast.ATypeExpr[X]) adlast.ATypeExpr[StructB[X]] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("exer01.struct_with_void", "StructB"),
		),
		[]adlast.TypeExpr{x.Value},
	)
	return adlast.Make_ATypeExpr[StructB[X]](te)
}

func AST_StructB() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StructB",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{
					"X",
				},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"B",
						"B",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Void",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("exer01.struct_with_void", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("exer01.struct_with_void", "StructB"),
		AST_StructB(),
	)
}

func Texpr_StructC() adlast.ATypeExpr[StructC] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("exer01.struct_with_void", "StructC"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StructC](te)
}

func AST_StructC() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StructC",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_reference(
						adlast.MakeAll_ScopedName(
							"exer01.struct_with_void",
							"StructOf",
						),
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("exer01.struct_with_void", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("exer01.struct_with_void", "StructC"),
		AST_StructC(),
	)
}

func Texpr_StructOf() adlast.ATypeExpr[StructOf] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("exer01.struct_with_void", "StructOf"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StructOf](te)
}

func AST_StructOf() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StructOf",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"A",
						"A",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Void",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("exer01.struct_with_void", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("exer01.struct_with_void", "StructOf"),
		AST_StructOf(),
	)
}
