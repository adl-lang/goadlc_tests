// Code generated by goadlc v3 - DO NOT EDIT.
package lifting

import (
	"fmt"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

type AddedField struct {
	_AddedField
}

type _AddedField struct {
	Quantity float64 `json:"quantity"`
	Value    int64   `json:"value"`
}

func MakeAll_AddedField(
	quantity float64,
	value int64,
) AddedField {
	return AddedField{
		_AddedField{
			Quantity: quantity,
			Value:    value,
		},
	}
}

func Make_AddedField(
	quantity float64,
	value int64,
) AddedField {
	ret := AddedField{
		_AddedField{
			Quantity: quantity,
			Value:    value,
		},
	}
	return ret
}

type Lifted struct {
	Branch LiftedBranch
}

type LiftedBranch interface {
	isLiftedBranch()
}

func (*Lifted) MakeNewBranch(key string) (any, error) {
	switch key {
	case "org_field":
		return &_Lifted_Org_field{}, nil
	case "option2":
		return &_Lifted_Option2{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Lifted_Org_field struct {
	V OrgField `branch:"org_field"`
}
type _Lifted_Option2 struct {
	V AddedField `branch:"option2"`
}

func (_Lifted_Org_field) isLiftedBranch() {}
func (_Lifted_Option2) isLiftedBranch()   {}

func Make_Lifted_org_field(v OrgField) Lifted {
	return Lifted{
		_Lifted_Org_field{v},
	}
}

func Make_Lifted_option2(v AddedField) Lifted {
	return Lifted{
		_Lifted_Option2{v},
	}
}

func (un Lifted) Cast_org_field() (OrgField, bool) {
	br, ok := un.Branch.(_Lifted_Org_field)
	return br.V, ok
}

func (un Lifted) Cast_option2() (AddedField, bool) {
	br, ok := un.Branch.(_Lifted_Option2)
	return br.V, ok
}

func Handle_Lifted[T any](
	_in Lifted,
	org_field func(org_field OrgField) T,
	option2 func(option2 AddedField) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Lifted_Org_field:
		if org_field != nil {
			return org_field(_b.V)
		}
	case _Lifted_Option2:
		if option2 != nil {
			return option2(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Lifted")
}

func HandleWithErr_Lifted[T any](
	_in Lifted,
	org_field func(org_field OrgField) (T, error),
	option2 func(option2 AddedField) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Lifted_Org_field:
		if org_field != nil {
			return org_field(_b.V)
		}
	case _Lifted_Option2:
		if option2 != nil {
			return option2(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Lifted")
}

type LiftedVector struct {
	Branch LiftedVectorBranch
}

type LiftedVectorBranch interface {
	isLiftedVectorBranch()
}

func (*LiftedVector) MakeNewBranch(key string) (any, error) {
	switch key {
	case "str_arr":
		return &_LiftedVector_Str_arr{}, nil
	case "count_strs":
		return &_LiftedVector_Count_strs{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _LiftedVector_Str_arr struct {
	V []string `branch:"str_arr"`
}
type _LiftedVector_Count_strs struct {
	V types.Pair[int64, []string] `branch:"count_strs"`
}

func (_LiftedVector_Str_arr) isLiftedVectorBranch()    {}
func (_LiftedVector_Count_strs) isLiftedVectorBranch() {}

func Make_LiftedVector_str_arr(v []string) LiftedVector {
	return LiftedVector{
		_LiftedVector_Str_arr{v},
	}
}

func Make_LiftedVector_count_strs(v types.Pair[int64, []string]) LiftedVector {
	return LiftedVector{
		_LiftedVector_Count_strs{v},
	}
}

func (un LiftedVector) Cast_str_arr() ([]string, bool) {
	br, ok := un.Branch.(_LiftedVector_Str_arr)
	return br.V, ok
}

func (un LiftedVector) Cast_count_strs() (types.Pair[int64, []string], bool) {
	br, ok := un.Branch.(_LiftedVector_Count_strs)
	return br.V, ok
}

func Handle_LiftedVector[T any](
	_in LiftedVector,
	str_arr func(str_arr []string) T,
	count_strs func(count_strs types.Pair[int64, []string]) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _LiftedVector_Str_arr:
		if str_arr != nil {
			return str_arr(_b.V)
		}
	case _LiftedVector_Count_strs:
		if count_strs != nil {
			return count_strs(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : LiftedVector")
}

func HandleWithErr_LiftedVector[T any](
	_in LiftedVector,
	str_arr func(str_arr []string) (T, error),
	count_strs func(count_strs types.Pair[int64, []string]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _LiftedVector_Str_arr:
		if str_arr != nil {
			return str_arr(_b.V)
		}
	case _LiftedVector_Count_strs:
		if count_strs != nil {
			return count_strs(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : LiftedVector")
}

type NewOutter struct {
	_NewOutter
}

type _NewOutter struct {
	Field0 Lifted `json:"field0"`
}

func MakeAll_NewOutter(
	field0 Lifted,
) NewOutter {
	return NewOutter{
		_NewOutter{
			Field0: field0,
		},
	}
}

func Make_NewOutter(
	field0 Lifted,
) NewOutter {
	ret := NewOutter{
		_NewOutter{
			Field0: field0,
		},
	}
	return ret
}

type OldOutter struct {
	_OldOutter
}

type _OldOutter struct {
	Field0 OrgField `json:"field0"`
}

func MakeAll_OldOutter(
	field0 OrgField,
) OldOutter {
	return OldOutter{
		_OldOutter{
			Field0: field0,
		},
	}
}

func Make_OldOutter(
	field0 OrgField,
) OldOutter {
	ret := OldOutter{
		_OldOutter{
			Field0: field0,
		},
	}
	return ret
}

type OrgField struct {
	_OrgField
}

type _OrgField struct {
	A string `json:"a"`
	B int64  `json:"b"`
}

func MakeAll_OrgField(
	a string,
	b int64,
) OrgField {
	return OrgField{
		_OrgField{
			A: a,
			B: b,
		},
	}
}

func Make_OrgField(
	a string,
	b int64,
) OrgField {
	ret := OrgField{
		_OrgField{
			A: a,
			B: b,
		},
	}
	return ret
}
