// Code generated by goadlc v3 - DO NOT EDIT.
package choice01

import (
	"fmt"
)

type ChoiceOne struct {
	Branch ChoiceOneBranch
}

type ChoiceOneBranch interface {
	isChoiceOneBranch()
}

func (*ChoiceOne) MakeNewBranch(key string) (any, error) {
	switch key {
	case "pattern":
		return &_ChoiceOne_Pattern{}, nil
	case "bootstrapping":
		return &_ChoiceOne_Bootstrapping{}, nil
	case "codeGen":
		return &_ChoiceOne_CodeGen{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _ChoiceOne_Pattern struct {
	V Sumtype `branch:"pattern"`
}
type _ChoiceOne_Bootstrapping struct {
	V []string `branch:"bootstrapping"`
}
type _ChoiceOne_CodeGen struct {
	V LangGen `branch:"codeGen"`
}

func (_ChoiceOne_Pattern) isChoiceOneBranch()       {}
func (_ChoiceOne_Bootstrapping) isChoiceOneBranch() {}
func (_ChoiceOne_CodeGen) isChoiceOneBranch()       {}

func Make_ChoiceOne_pattern(v Sumtype) ChoiceOne {
	return ChoiceOne{
		_ChoiceOne_Pattern{v},
	}
}

func Make_ChoiceOne_bootstrapping(v []string) ChoiceOne {
	return ChoiceOne{
		_ChoiceOne_Bootstrapping{v},
	}
}

func Make_ChoiceOne_codeGen(v LangGen) ChoiceOne {
	return ChoiceOne{
		_ChoiceOne_CodeGen{v},
	}
}

func (un ChoiceOne) Cast_pattern() (Sumtype, bool) {
	br, ok := un.Branch.(_ChoiceOne_Pattern)
	return br.V, ok
}

func (un ChoiceOne) Cast_bootstrapping() ([]string, bool) {
	br, ok := un.Branch.(_ChoiceOne_Bootstrapping)
	return br.V, ok
}

func (un ChoiceOne) Cast_codeGen() (LangGen, bool) {
	br, ok := un.Branch.(_ChoiceOne_CodeGen)
	return br.V, ok
}

func Handle_ChoiceOne[T any](
	_in ChoiceOne,
	pattern func(pattern Sumtype) T,
	bootstrapping func(bootstrapping []string) T,
	codeGen func(codeGen LangGen) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _ChoiceOne_Pattern:
		if pattern != nil {
			return pattern(_b.V)
		}
	case _ChoiceOne_Bootstrapping:
		if bootstrapping != nil {
			return bootstrapping(_b.V)
		}
	case _ChoiceOne_CodeGen:
		if codeGen != nil {
			return codeGen(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceOne")
}

func HandleWithErr_ChoiceOne[T any](
	_in ChoiceOne,
	pattern func(pattern Sumtype) (T, error),
	bootstrapping func(bootstrapping []string) (T, error),
	codeGen func(codeGen LangGen) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _ChoiceOne_Pattern:
		if pattern != nil {
			return pattern(_b.V)
		}
	case _ChoiceOne_Bootstrapping:
		if bootstrapping != nil {
			return bootstrapping(_b.V)
		}
	case _ChoiceOne_CodeGen:
		if codeGen != nil {
			return codeGen(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceOne")
}

type CodeGen[L any] struct {
	_CodeGen[L]
}

type _CodeGen[L any] struct {
	Language  L                `json:"language"`
	Technique CodeGenTechnique `json:"technique"`
}

func MakeAll_CodeGen[L any](
	language L,
	technique CodeGenTechnique,
) CodeGen[L] {
	return CodeGen[L]{
		_CodeGen[L]{
			Language:  language,
			Technique: technique,
		},
	}
}

func Make_CodeGen[L any](
	language L,
	technique CodeGenTechnique,
) CodeGen[L] {
	ret := CodeGen[L]{
		_CodeGen[L]{
			Language:  language,
			Technique: technique,
		},
	}
	return ret
}

type CodeGenTechnique struct {
	Branch CodeGenTechniqueBranch
}

type CodeGenTechniqueBranch interface {
	isCodeGenTechniqueBranch()
}

func (*CodeGenTechnique) MakeNewBranch(key string) (any, error) {
	switch key {
	case "printf":
		return &_CodeGenTechnique_Printf{}, nil
	case "templates":
		return &_CodeGenTechnique_Templates{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _CodeGenTechnique_Printf struct {
	V struct{} `branch:"printf"`
}
type _CodeGenTechnique_Templates struct {
	V struct{} `branch:"templates"`
}

func (_CodeGenTechnique_Printf) isCodeGenTechniqueBranch()    {}
func (_CodeGenTechnique_Templates) isCodeGenTechniqueBranch() {}

func Make_CodeGenTechnique_printf() CodeGenTechnique {
	return CodeGenTechnique{
		_CodeGenTechnique_Printf{struct{}{}},
	}
}

func Make_CodeGenTechnique_templates() CodeGenTechnique {
	return CodeGenTechnique{
		_CodeGenTechnique_Templates{struct{}{}},
	}
}

func (un CodeGenTechnique) Cast_printf() (struct{}, bool) {
	br, ok := un.Branch.(_CodeGenTechnique_Printf)
	return br.V, ok
}

func (un CodeGenTechnique) Cast_templates() (struct{}, bool) {
	br, ok := un.Branch.(_CodeGenTechnique_Templates)
	return br.V, ok
}

func Handle_CodeGenTechnique[T any](
	_in CodeGenTechnique,
	printf func(printf struct{}) T,
	templates func(templates struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _CodeGenTechnique_Printf:
		if printf != nil {
			return printf(_b.V)
		}
	case _CodeGenTechnique_Templates:
		if templates != nil {
			return templates(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : CodeGenTechnique")
}

func HandleWithErr_CodeGenTechnique[T any](
	_in CodeGenTechnique,
	printf func(printf struct{}) (T, error),
	templates func(templates struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _CodeGenTechnique_Printf:
		if printf != nil {
			return printf(_b.V)
		}
	case _CodeGenTechnique_Templates:
		if templates != nil {
			return templates(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : CodeGenTechnique")
}

type ExhaustiveSwitch[T any] struct {
	_ExhaustiveSwitch[T]
}

type _ExhaustiveSwitch[T any] struct {
	Sum_type Sumtype  `json:"sum_type"`
	Impl     TypeSafe `json:"impl"`
}

func MakeAll_ExhaustiveSwitch[T any](
	sum_type Sumtype,
	impl TypeSafe,
) ExhaustiveSwitch[T] {
	return ExhaustiveSwitch[T]{
		_ExhaustiveSwitch[T]{
			Sum_type: sum_type,
			Impl:     impl,
		},
	}
}

func Make_ExhaustiveSwitch[T any](
	sum_type Sumtype,
	impl TypeSafe,
) ExhaustiveSwitch[T] {
	ret := ExhaustiveSwitch[T]{
		_ExhaustiveSwitch[T]{
			Sum_type: sum_type,
			Impl:     impl,
		},
	}
	return ret
}

type LangGen CodeGen[Language]

type Language struct {
	Branch LanguageBranch
}

type LanguageBranch interface {
	isLanguageBranch()
}

func (*Language) MakeNewBranch(key string) (any, error) {
	switch key {
	case "go_":
		return &_Language_Go_{}, nil
	case "ts":
		return &_Language_Ts{}, nil
	case "java":
		return &_Language_Java{}, nil
	case "haskell":
		return &_Language_Haskell{}, nil
	case "rust":
		return &_Language_Rust{}, nil
	case "cpp":
		return &_Language_Cpp{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Language_Go_ struct {
	V struct{} `branch:"go_"`
}
type _Language_Ts struct {
	V struct{} `branch:"ts"`
}
type _Language_Java struct {
	V struct{} `branch:"java"`
}
type _Language_Haskell struct {
	V struct{} `branch:"haskell"`
}
type _Language_Rust struct {
	V struct{} `branch:"rust"`
}
type _Language_Cpp struct {
	V struct{} `branch:"cpp"`
}

func (_Language_Go_) isLanguageBranch()     {}
func (_Language_Ts) isLanguageBranch()      {}
func (_Language_Java) isLanguageBranch()    {}
func (_Language_Haskell) isLanguageBranch() {}
func (_Language_Rust) isLanguageBranch()    {}
func (_Language_Cpp) isLanguageBranch()     {}

func Make_Language_go_() Language {
	return Language{
		_Language_Go_{struct{}{}},
	}
}

func Make_Language_ts() Language {
	return Language{
		_Language_Ts{struct{}{}},
	}
}

func Make_Language_java() Language {
	return Language{
		_Language_Java{struct{}{}},
	}
}

func Make_Language_haskell() Language {
	return Language{
		_Language_Haskell{struct{}{}},
	}
}

func Make_Language_rust() Language {
	return Language{
		_Language_Rust{struct{}{}},
	}
}

func Make_Language_cpp() Language {
	return Language{
		_Language_Cpp{struct{}{}},
	}
}

func (un Language) Cast_go_() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Go_)
	return br.V, ok
}

func (un Language) Cast_ts() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Ts)
	return br.V, ok
}

func (un Language) Cast_java() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Java)
	return br.V, ok
}

func (un Language) Cast_haskell() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Haskell)
	return br.V, ok
}

func (un Language) Cast_rust() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Rust)
	return br.V, ok
}

func (un Language) Cast_cpp() (struct{}, bool) {
	br, ok := un.Branch.(_Language_Cpp)
	return br.V, ok
}

func Handle_Language[T any](
	_in Language,
	go_ func(go_ struct{}) T,
	ts func(ts struct{}) T,
	java func(java struct{}) T,
	haskell func(haskell struct{}) T,
	rust func(rust struct{}) T,
	cpp func(cpp struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Language_Go_:
		if go_ != nil {
			return go_(_b.V)
		}
	case _Language_Ts:
		if ts != nil {
			return ts(_b.V)
		}
	case _Language_Java:
		if java != nil {
			return java(_b.V)
		}
	case _Language_Haskell:
		if haskell != nil {
			return haskell(_b.V)
		}
	case _Language_Rust:
		if rust != nil {
			return rust(_b.V)
		}
	case _Language_Cpp:
		if cpp != nil {
			return cpp(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Language")
}

func HandleWithErr_Language[T any](
	_in Language,
	go_ func(go_ struct{}) (T, error),
	ts func(ts struct{}) (T, error),
	java func(java struct{}) (T, error),
	haskell func(haskell struct{}) (T, error),
	rust func(rust struct{}) (T, error),
	cpp func(cpp struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Language_Go_:
		if go_ != nil {
			return go_(_b.V)
		}
	case _Language_Ts:
		if ts != nil {
			return ts(_b.V)
		}
	case _Language_Java:
		if java != nil {
			return java(_b.V)
		}
	case _Language_Haskell:
		if haskell != nil {
			return haskell(_b.V)
		}
	case _Language_Rust:
		if rust != nil {
			return rust(_b.V)
		}
	case _Language_Cpp:
		if cpp != nil {
			return cpp(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Language")
}

type Page = string

type Step struct {
	_Step
}

type _Step struct {
	Description string `json:"description"`
}

func MakeAll_Step(
	description string,
) Step {
	return Step{
		_Step{
			Description: description,
		},
	}
}

func Make_Step() Step {
	ret := Step{
		_Step{
			Description: ((*Step)(nil)).Default_description(),
		},
	}
	return ret
}

func (*Step) Default_description() string {
	return "Hello World!"
}

type Sumtype struct {
	Branch SumtypeBranch
}

type SumtypeBranch interface {
	isSumtypeBranch()
}

func (*Sumtype) MakeNewBranch(key string) (any, error) {
	switch key {
	case "struct_of_pointers":
		return &_Sumtype_Struct_of_pointers{}, nil
	case "disc_and_any":
		return &_Sumtype_Disc_and_any{}, nil
	case "interface_with_private_method":
		return &_Sumtype_Interface_with_private_method{}, nil
	case "type_safe":
		return &_Sumtype_Type_safe[Sumtype]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Sumtype_Struct_of_pointers struct {
	V struct{} `branch:"struct_of_pointers"`
}
type _Sumtype_Disc_and_any struct {
	V struct{} `branch:"disc_and_any"`
}
type _Sumtype_Interface_with_private_method struct {
	V struct{} `branch:"interface_with_private_method"`
}
type _Sumtype_Type_safe[Sumtype any] struct {
	V ExhaustiveSwitch[Sumtype] `branch:"type_safe"`
}

func (_Sumtype_Struct_of_pointers) isSumtypeBranch()            {}
func (_Sumtype_Disc_and_any) isSumtypeBranch()                  {}
func (_Sumtype_Interface_with_private_method) isSumtypeBranch() {}
func (_Sumtype_Type_safe[Sumtype]) isSumtypeBranch()            {}

func Make_Sumtype_struct_of_pointers() Sumtype {
	return Sumtype{
		_Sumtype_Struct_of_pointers{struct{}{}},
	}
}

func Make_Sumtype_disc_and_any() Sumtype {
	return Sumtype{
		_Sumtype_Disc_and_any{struct{}{}},
	}
}

func Make_Sumtype_interface_with_private_method() Sumtype {
	return Sumtype{
		_Sumtype_Interface_with_private_method{struct{}{}},
	}
}

func Make_Sumtype_type_safe(v ExhaustiveSwitch[Sumtype]) Sumtype {
	return Sumtype{
		_Sumtype_Type_safe[Sumtype]{v},
	}
}

func (un Sumtype) Cast_struct_of_pointers() (struct{}, bool) {
	br, ok := un.Branch.(_Sumtype_Struct_of_pointers)
	return br.V, ok
}

func (un Sumtype) Cast_disc_and_any() (struct{}, bool) {
	br, ok := un.Branch.(_Sumtype_Disc_and_any)
	return br.V, ok
}

func (un Sumtype) Cast_interface_with_private_method() (struct{}, bool) {
	br, ok := un.Branch.(_Sumtype_Interface_with_private_method)
	return br.V, ok
}

func (un Sumtype) Cast_type_safe() (ExhaustiveSwitch[Sumtype], bool) {
	br, ok := un.Branch.(_Sumtype_Type_safe[Sumtype])
	return br.V, ok
}

func Handle_Sumtype[T any](
	_in Sumtype,
	struct_of_pointers func(struct_of_pointers struct{}) T,
	disc_and_any func(disc_and_any struct{}) T,
	interface_with_private_method func(interface_with_private_method struct{}) T,
	type_safe func(type_safe ExhaustiveSwitch[Sumtype]) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Sumtype_Struct_of_pointers:
		if struct_of_pointers != nil {
			return struct_of_pointers(_b.V)
		}
	case _Sumtype_Disc_and_any:
		if disc_and_any != nil {
			return disc_and_any(_b.V)
		}
	case _Sumtype_Interface_with_private_method:
		if interface_with_private_method != nil {
			return interface_with_private_method(_b.V)
		}
	case _Sumtype_Type_safe[Sumtype]:
		if type_safe != nil {
			return type_safe(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Sumtype")
}

func HandleWithErr_Sumtype[T any](
	_in Sumtype,
	struct_of_pointers func(struct_of_pointers struct{}) (T, error),
	disc_and_any func(disc_and_any struct{}) (T, error),
	interface_with_private_method func(interface_with_private_method struct{}) (T, error),
	type_safe func(type_safe ExhaustiveSwitch[Sumtype]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Sumtype_Struct_of_pointers:
		if struct_of_pointers != nil {
			return struct_of_pointers(_b.V)
		}
	case _Sumtype_Disc_and_any:
		if disc_and_any != nil {
			return disc_and_any(_b.V)
		}
	case _Sumtype_Interface_with_private_method:
		if interface_with_private_method != nil {
			return interface_with_private_method(_b.V)
		}
	case _Sumtype_Type_safe[Sumtype]:
		if type_safe != nil {
			return type_safe(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Sumtype")
}

type TypeSafe struct {
	Branch TypeSafeBranch
}

type TypeSafeBranch interface {
	isTypeSafeBranch()
}

func (*TypeSafe) MakeNewBranch(key string) (any, error) {
	switch key {
	case "callback":
		return &_TypeSafe_Callback{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _TypeSafe_Callback struct {
	V struct{} `branch:"callback"`
}

func (_TypeSafe_Callback) isTypeSafeBranch() {}

func Make_TypeSafe_callback() TypeSafe {
	return TypeSafe{
		_TypeSafe_Callback{struct{}{}},
	}
}

func (un TypeSafe) Cast_callback() (struct{}, bool) {
	br, ok := un.Branch.(_TypeSafe_Callback)
	return br.V, ok
}

func Handle_TypeSafe[T any](
	_in TypeSafe,
	callback func(callback struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _TypeSafe_Callback:
		if callback != nil {
			return callback(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeSafe")
}

func HandleWithErr_TypeSafe[T any](
	_in TypeSafe,
	callback func(callback struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _TypeSafe_Callback:
		if callback != nil {
			return callback(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeSafe")
}
