// Code generated by goadlc v3 - DO NOT EDIT.
package choice01

import (
	"fmt"
)

type ChoiceOne struct {
	Branch ChoiceOneBranch
}

type ChoiceOneBranch interface {
	isChoiceOneBranch()
}

func (*ChoiceOne) MakeNewBranch(key string) (any, error) {
	switch key {
	case "pattern":
		return &ChoiceOne_Pattern{}, nil
	case "bootstrapping":
		return &ChoiceOne_Bootstrapping{}, nil
	case "codeGen":
		return &ChoiceOne_CodeGen{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type ChoiceOne_Pattern struct {
	V Sumtype `branch:"pattern"`
}
type ChoiceOne_Bootstrapping struct {
	V []string `branch:"bootstrapping"`
}
type ChoiceOne_CodeGen struct {
	V LangGen `branch:"codeGen"`
}

func (ChoiceOne_Pattern) isChoiceOneBranch()       {}
func (ChoiceOne_Bootstrapping) isChoiceOneBranch() {}
func (ChoiceOne_CodeGen) isChoiceOneBranch()       {}

func Make_ChoiceOne_pattern(v Sumtype) ChoiceOne {
	return ChoiceOne{
		ChoiceOne_Pattern{v},
	}
}

func Make_ChoiceOne_bootstrapping(v []string) ChoiceOne {
	return ChoiceOne{
		ChoiceOne_Bootstrapping{v},
	}
}

func Make_ChoiceOne_codeGen(v LangGen) ChoiceOne {
	return ChoiceOne{
		ChoiceOne_CodeGen{v},
	}
}

func Handle_ChoiceOne[T any](
	_in ChoiceOneBranch,
	pattern func(pattern Sumtype) T,
	bootstrapping func(bootstrapping []string) T,
	codeGen func(codeGen LangGen) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case ChoiceOne_Pattern:
		if pattern != nil {
			return pattern(_b.V)
		}
	case ChoiceOne_Bootstrapping:
		if bootstrapping != nil {
			return bootstrapping(_b.V)
		}
	case ChoiceOne_CodeGen:
		if codeGen != nil {
			return codeGen(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceOne")
}

func HandleWithErr_ChoiceOne[T any](
	_in ChoiceOneBranch,
	pattern func(pattern Sumtype) (T, error),
	bootstrapping func(bootstrapping []string) (T, error),
	codeGen func(codeGen LangGen) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case ChoiceOne_Pattern:
		if pattern != nil {
			return pattern(_b.V)
		}
	case ChoiceOne_Bootstrapping:
		if bootstrapping != nil {
			return bootstrapping(_b.V)
		}
	case ChoiceOne_CodeGen:
		if codeGen != nil {
			return codeGen(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : ChoiceOne")
}

type CodeGen[L any] struct {
	Language  L                `json:"language"`
	Technique CodeGenTechnique `json:"technique"`
}

func New_CodeGen[L any](
	language L,
	technique CodeGenTechnique,
) CodeGen[L] {
	return CodeGen[L]{
		Language:  language,
		Technique: technique,
	}
}

func Make_CodeGen[L any](
	language L,
	technique CodeGenTechnique,
) CodeGen[L] {
	ret := CodeGen[L]{
		Language:  language,
		Technique: technique,
	}
	return ret
}

type CodeGenTechnique struct {
	Branch CodeGenTechniqueBranch
}

type CodeGenTechniqueBranch interface {
	isCodeGenTechniqueBranch()
}

func (*CodeGenTechnique) MakeNewBranch(key string) (any, error) {
	switch key {
	case "printf":
		return &CodeGenTechnique_Printf{}, nil
	case "templates":
		return &CodeGenTechnique_Templates{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type CodeGenTechnique_Printf struct {
	V struct{} `branch:"printf"`
}
type CodeGenTechnique_Templates struct {
	V struct{} `branch:"templates"`
}

func (CodeGenTechnique_Printf) isCodeGenTechniqueBranch()    {}
func (CodeGenTechnique_Templates) isCodeGenTechniqueBranch() {}

func Make_CodeGenTechnique_printf(v struct{}) CodeGenTechnique {
	return CodeGenTechnique{
		CodeGenTechnique_Printf{v},
	}
}

func Make_CodeGenTechnique_templates(v struct{}) CodeGenTechnique {
	return CodeGenTechnique{
		CodeGenTechnique_Templates{v},
	}
}

func Handle_CodeGenTechnique[T any](
	_in CodeGenTechniqueBranch,
	printf func(printf struct{}) T,
	templates func(templates struct{}) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case CodeGenTechnique_Printf:
		if printf != nil {
			return printf(_b.V)
		}
	case CodeGenTechnique_Templates:
		if templates != nil {
			return templates(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : CodeGenTechnique")
}

func HandleWithErr_CodeGenTechnique[T any](
	_in CodeGenTechniqueBranch,
	printf func(printf struct{}) (T, error),
	templates func(templates struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case CodeGenTechnique_Printf:
		if printf != nil {
			return printf(_b.V)
		}
	case CodeGenTechnique_Templates:
		if templates != nil {
			return templates(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : CodeGenTechnique")
}

type ExhaustiveSwitch[T any] struct {
	Sum_type Sumtype  `json:"sum_type"`
	Impl     TypeSafe `json:"impl"`
}

func New_ExhaustiveSwitch[T any](
	sum_type Sumtype,
	impl TypeSafe,
) ExhaustiveSwitch[T] {
	return ExhaustiveSwitch[T]{
		Sum_type: sum_type,
		Impl:     impl,
	}
}

func Make_ExhaustiveSwitch[T any](
	sum_type Sumtype,
	impl TypeSafe,
) ExhaustiveSwitch[T] {
	ret := ExhaustiveSwitch[T]{
		Sum_type: sum_type,
		Impl:     impl,
	}
	return ret
}

type LangGen CodeGen[Language]

type Language struct {
	Branch LanguageBranch
}

type LanguageBranch interface {
	isLanguageBranch()
}

func (*Language) MakeNewBranch(key string) (any, error) {
	switch key {
	case "go_":
		return &Language_Go_{}, nil
	case "ts":
		return &Language_Ts{}, nil
	case "java":
		return &Language_Java{}, nil
	case "haskell":
		return &Language_Haskell{}, nil
	case "rust":
		return &Language_Rust{}, nil
	case "cpp":
		return &Language_Cpp{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type Language_Go_ struct {
	V struct{} `branch:"go_"`
}
type Language_Ts struct {
	V struct{} `branch:"ts"`
}
type Language_Java struct {
	V struct{} `branch:"java"`
}
type Language_Haskell struct {
	V struct{} `branch:"haskell"`
}
type Language_Rust struct {
	V struct{} `branch:"rust"`
}
type Language_Cpp struct {
	V struct{} `branch:"cpp"`
}

func (Language_Go_) isLanguageBranch()     {}
func (Language_Ts) isLanguageBranch()      {}
func (Language_Java) isLanguageBranch()    {}
func (Language_Haskell) isLanguageBranch() {}
func (Language_Rust) isLanguageBranch()    {}
func (Language_Cpp) isLanguageBranch()     {}

func Make_Language_go_(v struct{}) Language {
	return Language{
		Language_Go_{v},
	}
}

func Make_Language_ts(v struct{}) Language {
	return Language{
		Language_Ts{v},
	}
}

func Make_Language_java(v struct{}) Language {
	return Language{
		Language_Java{v},
	}
}

func Make_Language_haskell(v struct{}) Language {
	return Language{
		Language_Haskell{v},
	}
}

func Make_Language_rust(v struct{}) Language {
	return Language{
		Language_Rust{v},
	}
}

func Make_Language_cpp(v struct{}) Language {
	return Language{
		Language_Cpp{v},
	}
}

func Handle_Language[T any](
	_in LanguageBranch,
	go_ func(go_ struct{}) T,
	ts func(ts struct{}) T,
	java func(java struct{}) T,
	haskell func(haskell struct{}) T,
	rust func(rust struct{}) T,
	cpp func(cpp struct{}) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case Language_Go_:
		if go_ != nil {
			return go_(_b.V)
		}
	case Language_Ts:
		if ts != nil {
			return ts(_b.V)
		}
	case Language_Java:
		if java != nil {
			return java(_b.V)
		}
	case Language_Haskell:
		if haskell != nil {
			return haskell(_b.V)
		}
	case Language_Rust:
		if rust != nil {
			return rust(_b.V)
		}
	case Language_Cpp:
		if cpp != nil {
			return cpp(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Language")
}

func HandleWithErr_Language[T any](
	_in LanguageBranch,
	go_ func(go_ struct{}) (T, error),
	ts func(ts struct{}) (T, error),
	java func(java struct{}) (T, error),
	haskell func(haskell struct{}) (T, error),
	rust func(rust struct{}) (T, error),
	cpp func(cpp struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case Language_Go_:
		if go_ != nil {
			return go_(_b.V)
		}
	case Language_Ts:
		if ts != nil {
			return ts(_b.V)
		}
	case Language_Java:
		if java != nil {
			return java(_b.V)
		}
	case Language_Haskell:
		if haskell != nil {
			return haskell(_b.V)
		}
	case Language_Rust:
		if rust != nil {
			return rust(_b.V)
		}
	case Language_Cpp:
		if cpp != nil {
			return cpp(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Language")
}

type Page = string

type Step struct {
	Description string `json:"description"`
}

func New_Step(
	description string,
) Step {
	return Step{
		Description: description,
	}
}

func Make_Step(
	description string,
) Step {
	ret := Step{
		Description: description,
	}
	return ret
}

type Sumtype struct {
	Branch SumtypeBranch
}

type SumtypeBranch interface {
	isSumtypeBranch()
}

func (*Sumtype) MakeNewBranch(key string) (any, error) {
	switch key {
	case "struct_of_pointers":
		return &Sumtype_Struct_of_pointers{}, nil
	case "disc_and_any":
		return &Sumtype_Disc_and_any{}, nil
	case "interface_with_private_method":
		return &Sumtype_Interface_with_private_method{}, nil
	case "type_safe":
		return &Sumtype_Type_safe[Sumtype]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type Sumtype_Struct_of_pointers struct {
	V struct{} `branch:"struct_of_pointers"`
}
type Sumtype_Disc_and_any struct {
	V struct{} `branch:"disc_and_any"`
}
type Sumtype_Interface_with_private_method struct {
	V struct{} `branch:"interface_with_private_method"`
}
type Sumtype_Type_safe[Sumtype any] struct {
	V ExhaustiveSwitch[Sumtype] `branch:"type_safe"`
}

func (Sumtype_Struct_of_pointers) isSumtypeBranch()            {}
func (Sumtype_Disc_and_any) isSumtypeBranch()                  {}
func (Sumtype_Interface_with_private_method) isSumtypeBranch() {}
func (Sumtype_Type_safe[Sumtype]) isSumtypeBranch()            {}

func Make_Sumtype_struct_of_pointers(v struct{}) Sumtype {
	return Sumtype{
		Sumtype_Struct_of_pointers{v},
	}
}

func Make_Sumtype_disc_and_any(v struct{}) Sumtype {
	return Sumtype{
		Sumtype_Disc_and_any{v},
	}
}

func Make_Sumtype_interface_with_private_method(v struct{}) Sumtype {
	return Sumtype{
		Sumtype_Interface_with_private_method{v},
	}
}

func Make_Sumtype_type_safe(v ExhaustiveSwitch[Sumtype]) Sumtype {
	return Sumtype{
		Sumtype_Type_safe[Sumtype]{v},
	}
}

func Handle_Sumtype[T any](
	_in SumtypeBranch,
	struct_of_pointers func(struct_of_pointers struct{}) T,
	disc_and_any func(disc_and_any struct{}) T,
	interface_with_private_method func(interface_with_private_method struct{}) T,
	type_safe func(type_safe ExhaustiveSwitch[Sumtype]) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case Sumtype_Struct_of_pointers:
		if struct_of_pointers != nil {
			return struct_of_pointers(_b.V)
		}
	case Sumtype_Disc_and_any:
		if disc_and_any != nil {
			return disc_and_any(_b.V)
		}
	case Sumtype_Interface_with_private_method:
		if interface_with_private_method != nil {
			return interface_with_private_method(_b.V)
		}
	case Sumtype_Type_safe[Sumtype]:
		if type_safe != nil {
			return type_safe(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Sumtype")
}

func HandleWithErr_Sumtype[T any](
	_in SumtypeBranch,
	struct_of_pointers func(struct_of_pointers struct{}) (T, error),
	disc_and_any func(disc_and_any struct{}) (T, error),
	interface_with_private_method func(interface_with_private_method struct{}) (T, error),
	type_safe func(type_safe ExhaustiveSwitch[Sumtype]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case Sumtype_Struct_of_pointers:
		if struct_of_pointers != nil {
			return struct_of_pointers(_b.V)
		}
	case Sumtype_Disc_and_any:
		if disc_and_any != nil {
			return disc_and_any(_b.V)
		}
	case Sumtype_Interface_with_private_method:
		if interface_with_private_method != nil {
			return interface_with_private_method(_b.V)
		}
	case Sumtype_Type_safe[Sumtype]:
		if type_safe != nil {
			return type_safe(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Sumtype")
}

type TypeSafe struct {
	Branch TypeSafeBranch
}

type TypeSafeBranch interface {
	isTypeSafeBranch()
}

func (*TypeSafe) MakeNewBranch(key string) (any, error) {
	switch key {
	case "callback":
		return &TypeSafe_Callback{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type TypeSafe_Callback struct {
	V struct{} `branch:"callback"`
}

func (TypeSafe_Callback) isTypeSafeBranch() {}

func Make_TypeSafe_callback(v struct{}) TypeSafe {
	return TypeSafe{
		TypeSafe_Callback{v},
	}
}

func Handle_TypeSafe[T any](
	_in TypeSafeBranch,
	callback func(callback struct{}) T,
	_default func() T,
) T {
	switch _b := _in.(type) {
	case TypeSafe_Callback:
		if callback != nil {
			return callback(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeSafe")
}

func HandleWithErr_TypeSafe[T any](
	_in TypeSafeBranch,
	callback func(callback struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.(type) {
	case TypeSafe_Callback:
		if callback != nil {
			return callback(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : TypeSafe")
}
