// Code generated by goadlc v3 - DO NOT EDIT.
package choice01

import (
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

func Texpr_ChoiceOne() goadl.ATypeExpr[ChoiceOne] {
	return goadl.ATypeExpr[ChoiceOne]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "ChoiceOne",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_ChoiceOne() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "ChoiceOne",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Union_{
				V: adlast.Union{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "pattern",
							SerializedName: "pattern",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "Sumtype",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "bootstrapping",
							SerializedName: "bootstrapping",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Vector"},
								},
								Parameters: []adlast.TypeExpr{
									adlast.TypeExpr{
										TypeRef: adlast.TypeRef{
											Branch: adlast.TypeRef_Primitive{
												V: "String"},
										},
										Parameters: []adlast.TypeExpr{},
									},
								},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "codeGen",
							SerializedName: "codeGen",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "LangGen",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Just[any]{
									V: map[string]interface{}{"language": "go_", "technique": "templates"}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{ /**/ adlast.ScopedName{ModuleName: "talk.choice01", Name: "Page"}: "Introduction to ADL"},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "ChoiceOne"},
		AST_ChoiceOne(),
	)
}

func Texpr_CodeGen[L any](l goadl.ATypeExpr[L]) goadl.ATypeExpr[CodeGen[L]] {
	return goadl.ATypeExpr[CodeGen[L]]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "CodeGen",
					},
				},
			},
			Parameters: []adlast.TypeExpr{l.Value},
		},
	}
}

func AST_CodeGen() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "CodeGen",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Struct_{
				V: adlast.Struct{
					TypeParams: []adlast.Ident{
						"L",
					},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "language",
							SerializedName: "language",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_TypeParam{
										V: "L"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "technique",
							SerializedName: "technique",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "CodeGenTechnique",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "CodeGen"},
		AST_CodeGen(),
	)
}

func Texpr_CodeGenTechnique() goadl.ATypeExpr[CodeGenTechnique] {
	return goadl.ATypeExpr[CodeGenTechnique]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "CodeGenTechnique",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_CodeGenTechnique() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "CodeGenTechnique",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Union_{
				V: adlast.Union{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "printf",
							SerializedName: "printf",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "templates",
							SerializedName: "templates",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "CodeGenTechnique"},
		AST_CodeGenTechnique(),
	)
}

func Texpr_ExhaustiveSwitch[T any](t goadl.ATypeExpr[T]) goadl.ATypeExpr[ExhaustiveSwitch[T]] {
	return goadl.ATypeExpr[ExhaustiveSwitch[T]]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "ExhaustiveSwitch",
					},
				},
			},
			Parameters: []adlast.TypeExpr{t.Value},
		},
	}
}

func AST_ExhaustiveSwitch() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "ExhaustiveSwitch",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Struct_{
				V: adlast.Struct{
					TypeParams: []adlast.Ident{
						"T",
					},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "sum_type",
							SerializedName: "sum_type",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "Sumtype",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "impl",
							SerializedName: "impl",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "TypeSafe",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "ExhaustiveSwitch"},
		AST_ExhaustiveSwitch(),
	)
}

func Texpr_LangGen() goadl.ATypeExpr[LangGen] {
	return goadl.ATypeExpr[LangGen]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "LangGen",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_LangGen() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "LangGen",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Newtype_{
				V: adlast.NewType{
					TypeParams: []adlast.Ident{},
					TypeExpr: adlast.TypeExpr{
						TypeRef: adlast.TypeRef{
							Branch: adlast.TypeRef_Reference{
								V: adlast.ScopedName{
									ModuleName: "talk.choice01",
									Name:       "CodeGen",
								}},
						},
						Parameters: []adlast.TypeExpr{
							adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "Language",
										}},
								},
								Parameters: []adlast.TypeExpr{},
							},
						},
					},
					Default: types.Maybe[any]{
						Branch: types.Maybe_Nothing{
							V: struct{}{}},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "LangGen"},
		AST_LangGen(),
	)
}

func Texpr_Language() goadl.ATypeExpr[Language] {
	return goadl.ATypeExpr[Language]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "Language",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_Language() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "Language",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Union_{
				V: adlast.Union{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "go_",
							SerializedName: "go_",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "ts",
							SerializedName: "ts",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "java",
							SerializedName: "java",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "haskell",
							SerializedName: "haskell",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "rust",
							SerializedName: "rust",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "cpp",
							SerializedName: "cpp",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "Language"},
		AST_Language(),
	)
}

func Texpr_Page() goadl.ATypeExpr[Page] {
	return goadl.ATypeExpr[Page]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "Page",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_Page() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "Page",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Type_{
				V: adlast.TypeDef{
					TypeParams: []adlast.Ident{},
					TypeExpr: adlast.TypeExpr{
						TypeRef: adlast.TypeRef{
							Branch: adlast.TypeRef_Primitive{
								V: "String"},
						},
						Parameters: []adlast.TypeExpr{},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "Page"},
		AST_Page(),
	)
}

func Texpr_Step() goadl.ATypeExpr[Step] {
	return goadl.ATypeExpr[Step]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "Step",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_Step() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "Step",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Struct_{
				V: adlast.Struct{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "description",
							SerializedName: "description",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "String"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "Step"},
		AST_Step(),
	)
}

func Texpr_Sumtype() goadl.ATypeExpr[Sumtype] {
	return goadl.ATypeExpr[Sumtype]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "Sumtype",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_Sumtype() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "Sumtype",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Union_{
				V: adlast.Union{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "struct_of_pointers",
							SerializedName: "struct_of_pointers",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "disc_and_any",
							SerializedName: "disc_and_any",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "interface_with_private_method",
							SerializedName: "interface_with_private_method",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
						adlast.Field{
							Name:           "type_safe",
							SerializedName: "type_safe",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Reference{
										V: adlast.ScopedName{
											ModuleName: "talk.choice01",
											Name:       "ExhaustiveSwitch",
										}},
								},
								Parameters: []adlast.TypeExpr{
									adlast.TypeExpr{
										TypeRef: adlast.TypeRef{
											Branch: adlast.TypeRef_Reference{
												V: adlast.ScopedName{
													ModuleName: "talk.choice01",
													Name:       "Sumtype",
												}},
										},
										Parameters: []adlast.TypeExpr{},
									},
								},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "Sumtype"},
		AST_Sumtype(),
	)
}

func Texpr_TypeSafe() goadl.ATypeExpr[TypeSafe] {
	return goadl.ATypeExpr[TypeSafe]{
		Value: adlast.TypeExpr{
			TypeRef: adlast.TypeRef{
				Branch: adlast.TypeRef_Reference{
					V: adlast.ScopedName{
						ModuleName: "talk.choice01",
						Name:       "TypeSafe",
					},
				},
			},
			Parameters: []adlast.TypeExpr{},
		},
	}
}

func AST_TypeSafe() adlast.ScopedDecl {
	decl := adlast.Decl{
		Name: "TypeSafe",
		Version: types.Maybe[uint32]{
			Branch: types.Maybe_Nothing{
				V: struct{}{}},
		},
		Type_: adlast.DeclType{
			Branch: adlast.DeclType_Union_{
				V: adlast.Union{
					TypeParams: []adlast.Ident{},
					Fields: []adlast.Field{
						adlast.Field{
							Name:           "callback",
							SerializedName: "callback",
							TypeExpr: adlast.TypeExpr{
								TypeRef: adlast.TypeRef{
									Branch: adlast.TypeRef_Primitive{
										V: "Void"},
								},
								Parameters: []adlast.TypeExpr{},
							},
							Default: types.Maybe[any]{
								Branch: types.Maybe_Nothing{
									V: struct{}{}},
							},
							Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
						},
					},
				}},
		},
		Annotations: customtypes.MapMap[adlast.ScopedName, any]{},
	}
	return adlast.ScopedDecl{
		ModuleName: "talk.choice01",
		Decl:       decl,
	}
}

func init() {
	goadl.RESOLVER.Register(
		adlast.ScopedName{ModuleName: "talk.choice01", Name: "TypeSafe"},
		AST_TypeSafe(),
	)
}
