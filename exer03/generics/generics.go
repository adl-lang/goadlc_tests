// Code generated by goadlc v3 - DO NOT EDIT.
package generics

import (
	"fmt"
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

type Abc[A comparable, B any] struct {
	_Abc[A, B]
}

type _Abc[A comparable, B any] struct {
	A               A                             `json:"a"`
	B               []B                           `json:"b"`
	Kids            []Abc[A, B]                   `json:"kids"`
	Grandkids_named map[string]Abc[int64, string] `json:"grandkids_named"`
	C               int64                         `json:"c"`
	D               Def[A, B]                     `json:"d"`
	E               Def[int64, string]            `json:"e"`
	F               *Abc[int64, string]           `json:"f"`
}

func MakeAll_Abc[A comparable, B any](
	a A,
	b []B,
	kids []Abc[A, B],
	grandkids_named map[string]Abc[int64, string],
	c int64,
	d Def[A, B],
	e Def[int64, string],
	f *Abc[int64, string],
) Abc[A, B] {
	return Abc[A, B]{
		_Abc[A, B]{
			A:               a,
			B:               b,
			Kids:            kids,
			Grandkids_named: grandkids_named,
			C:               c,
			D:               d,
			E:               e,
			F:               f,
		},
	}
}

func Make_Abc[A comparable, B any](
	a A,
	b []B,
	d Def[A, B],
) Abc[A, B] {
	ret := Abc[A, B]{
		_Abc[A, B]{
			A:               a,
			B:               b,
			Kids:            ((*Abc[A, B])(nil)).Default_kids(),
			Grandkids_named: ((*Abc[A, B])(nil)).Default_grandkids_named(),
			C:               ((*Abc[A, B])(nil)).Default_c(),
			D:               d,
			E:               ((*Abc[A, B])(nil)).Default_e(),
			F:               ((*Abc[A, B])(nil)).Default_f(),
		},
	}
	return ret
}

func (*Abc[A, B]) Default_kids() []Abc[A, B] {
	return []Abc[A, B]{}
}
func (*Abc[A, B]) Default_grandkids_named() map[string]Abc[int64, string] {
	return map[string]Abc[int64, string]{
		"fav": MakeAll_Abc[int64, string](
			4321,
			[]string{
				"aaa",
			},
			[]Abc[int64, string]{},
			map[string]Abc[int64, string]{},
			99,
			Make_Def_d[int64, string](
				Make_Def_a[int64, string](
					22,
				),
			),
			Make_Def_a[int64, string](
				1234,
			),
			nil,
		),
	}
}
func (*Abc[A, B]) Default_c() int64 {
	return 66
}
func (*Abc[A, B]) Default_e() Def[int64, string] {
	return Make_Def_a[int64, string](
		1234,
	)
}
func (*Abc[A, B]) Default_f() *Abc[int64, string] {
	return goadl.Addr(MakeAll_Abc[int64, string](
		4321,
		[]string{
			"aaa",
		},
		[]Abc[int64, string]{},
		map[string]Abc[int64, string]{
			"fav": MakeAll_Abc[int64, string](
				4321,
				[]string{
					"aaa",
				},
				[]Abc[int64, string]{},
				map[string]Abc[int64, string]{},
				99,
				Make_Def_d[int64, string](
					Make_Def_a[int64, string](
						22,
					),
				),
				Make_Def_a[int64, string](
					1234,
				),
				nil,
			),
		},
		99,
		Make_Def_d[int64, string](
			Make_Def_a[int64, string](
				22,
			),
		),
		Make_Def_a[int64, string](
			1234,
		),
		nil,
	))
}

type Def[C comparable, D any] struct {
	Branch DefBranch[C, D]
}

type DefBranch[C comparable, D any] interface {
	isDefBranch()
}

func (*Def[C, D]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "a":
		return &_Def_A[C]{}, nil
	case "b":
		return &_Def_B[D]{}, nil
	case "c":
		return &_Def_C{}, nil
	case "d":
		return &_Def_D[C, D]{}, nil
	case "e":
		return &_Def_E{}, nil
	case "f":
		return &_Def_F{}, nil
	case "f2":
		return &_Def_F2[C]{}, nil
	case "g":
		return &_Def_G{}, nil
	case "g1":
		return &_Def_G1[C]{}, nil
	case "g2":
		return &_Def_G2[C]{}, nil
	case "g3":
		return &_Def_G3[C]{}, nil
	case "g4":
		return &_Def_G4[C]{}, nil
	case "g5":
		return &_Def_G5[C]{}, nil
	case "g6":
		return &_Def_G6[C]{}, nil
	case "g7":
		return &_Def_G7[D, C]{}, nil
	case "g8":
		return &_Def_G8[C]{}, nil
	case "g9":
		return &_Def_G9[C, D]{}, nil
	case "g10":
		return &_Def_G10[D, C]{}, nil
	case "h":
		return &_Def_H[C]{}, nil
	case "i":
		return &_Def_I[C]{}, nil
	case "m1":
		return &_Def_M1{}, nil
	case "m2":
		return &_Def_M2[C]{}, nil
	case "m3":
		return &_Def_M3[C]{}, nil
	case "m4":
		return &_Def_M4[C, D]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Def_A[C comparable] struct {
	V C `branch:"a"`
}
type _Def_B[D any] struct {
	V []D `branch:"b"`
}
type _Def_C struct {
	V int64 `branch:"c"`
}
type _Def_D[C comparable, D any] struct {
	V Def[C, D] `branch:"d"`
}
type _Def_E struct {
	V Abc[types.Either[string, int64], string] `branch:"e"`
}
type _Def_F struct {
	V []types.Either[string, types.Either[string, int64]] `branch:"f"`
}
type _Def_F2[C comparable] struct {
	V []types.Either[C, types.Either[string, int64]] `branch:"f2"`
}
type _Def_G struct {
	V types.Either[[]string, types.Either[string, int64]] `branch:"g"`
}
type _Def_G1[C comparable] struct {
	V types.Either[[]C, types.Either[C, C]] `branch:"g1"`
}
type _Def_G2[C comparable] struct {
	V types.Either[*C, types.Either[C, C]] `branch:"g2"`
}
type _Def_G3[C comparable] struct {
	V types.Either[map[string]C, types.Either[C, C]] `branch:"g3"`
}
type _Def_G4[C comparable] struct {
	V types.Either[[]string, types.Either[C, C]] `branch:"g4"`
}
type _Def_G5[C comparable] struct {
	V types.Either[types.Either[C, C], []string] `branch:"g5"`
}
type _Def_G6[C comparable] struct {
	V types.Either[types.Either[string, string], []C] `branch:"g6"`
}
type _Def_G7[D any, C comparable] struct {
	V types.Either[types.Either[D, string], []C] `branch:"g7"`
}
type _Def_G8[C comparable] struct {
	V types.Either[[]C, []C] `branch:"g8"`
}
type _Def_G9[C comparable, D any] struct {
	V types.Either[[]C, []D] `branch:"g9"`
}
type _Def_G10[D any, C comparable] struct {
	V types.Either[[]D, []C] `branch:"g10"`
}
type _Def_H[C comparable] struct {
	V []C `branch:"h"`
}
type _Def_I[C comparable] struct {
	V [][]C `branch:"i"`
}
type _Def_M1 struct {
	V customtypes.MapMap[string, int64] `branch:"m1"`
}
type _Def_M2[C comparable] struct {
	V customtypes.MapMap[C, int64] `branch:"m2"`
}
type _Def_M3[C comparable] struct {
	V customtypes.MapMap[string, C] `branch:"m3"`
}
type _Def_M4[C comparable, D any] struct {
	V customtypes.MapMap[C, D] `branch:"m4"`
}

func (_Def_A[C]) isDefBranch()      {}
func (_Def_B[D]) isDefBranch()      {}
func (_Def_C) isDefBranch()         {}
func (_Def_D[C, D]) isDefBranch()   {}
func (_Def_E) isDefBranch()         {}
func (_Def_F) isDefBranch()         {}
func (_Def_F2[C]) isDefBranch()     {}
func (_Def_G) isDefBranch()         {}
func (_Def_G1[C]) isDefBranch()     {}
func (_Def_G2[C]) isDefBranch()     {}
func (_Def_G3[C]) isDefBranch()     {}
func (_Def_G4[C]) isDefBranch()     {}
func (_Def_G5[C]) isDefBranch()     {}
func (_Def_G6[C]) isDefBranch()     {}
func (_Def_G7[D, C]) isDefBranch()  {}
func (_Def_G8[C]) isDefBranch()     {}
func (_Def_G9[C, D]) isDefBranch()  {}
func (_Def_G10[D, C]) isDefBranch() {}
func (_Def_H[C]) isDefBranch()      {}
func (_Def_I[C]) isDefBranch()      {}
func (_Def_M1) isDefBranch()        {}
func (_Def_M2[C]) isDefBranch()     {}
func (_Def_M3[C]) isDefBranch()     {}
func (_Def_M4[C, D]) isDefBranch()  {}

func Make_Def_a[C comparable, D any](v C) Def[C, D] {
	return Def[C, D]{
		_Def_A[C]{v},
	}
}

func Make_Def_b[C comparable, D any](v []D) Def[C, D] {
	return Def[C, D]{
		_Def_B[D]{v},
	}
}

func Make_Def_c[C comparable, D any](v int64) Def[C, D] {
	return Def[C, D]{
		_Def_C{v},
	}
}

func Make_Def_d[C comparable, D any](v Def[C, D]) Def[C, D] {
	return Def[C, D]{
		_Def_D[C, D]{v},
	}
}

func Make_Def_e[C comparable, D any](v Abc[types.Either[string, int64], string]) Def[C, D] {
	return Def[C, D]{
		_Def_E{v},
	}
}

func Make_Def_f[C comparable, D any](v []types.Either[string, types.Either[string, int64]]) Def[C, D] {
	return Def[C, D]{
		_Def_F{v},
	}
}

func Make_Def_f2[C comparable, D any](v []types.Either[C, types.Either[string, int64]]) Def[C, D] {
	return Def[C, D]{
		_Def_F2[C]{v},
	}
}

func Make_Def_g[C comparable, D any](v types.Either[[]string, types.Either[string, int64]]) Def[C, D] {
	return Def[C, D]{
		_Def_G{v},
	}
}

func Make_Def_g1[C comparable, D any](v types.Either[[]C, types.Either[C, C]]) Def[C, D] {
	return Def[C, D]{
		_Def_G1[C]{v},
	}
}

func Make_Def_g2[C comparable, D any](v types.Either[*C, types.Either[C, C]]) Def[C, D] {
	return Def[C, D]{
		_Def_G2[C]{v},
	}
}

func Make_Def_g3[C comparable, D any](v types.Either[map[string]C, types.Either[C, C]]) Def[C, D] {
	return Def[C, D]{
		_Def_G3[C]{v},
	}
}

func Make_Def_g4[C comparable, D any](v types.Either[[]string, types.Either[C, C]]) Def[C, D] {
	return Def[C, D]{
		_Def_G4[C]{v},
	}
}

func Make_Def_g5[C comparable, D any](v types.Either[types.Either[C, C], []string]) Def[C, D] {
	return Def[C, D]{
		_Def_G5[C]{v},
	}
}

func Make_Def_g6[C comparable, D any](v types.Either[types.Either[string, string], []C]) Def[C, D] {
	return Def[C, D]{
		_Def_G6[C]{v},
	}
}

func Make_Def_g7[C comparable, D any](v types.Either[types.Either[D, string], []C]) Def[C, D] {
	return Def[C, D]{
		_Def_G7[D, C]{v},
	}
}

func Make_Def_g8[C comparable, D any](v types.Either[[]C, []C]) Def[C, D] {
	return Def[C, D]{
		_Def_G8[C]{v},
	}
}

func Make_Def_g9[C comparable, D any](v types.Either[[]C, []D]) Def[C, D] {
	return Def[C, D]{
		_Def_G9[C, D]{v},
	}
}

func Make_Def_g10[C comparable, D any](v types.Either[[]D, []C]) Def[C, D] {
	return Def[C, D]{
		_Def_G10[D, C]{v},
	}
}

func Make_Def_h[C comparable, D any](v []C) Def[C, D] {
	return Def[C, D]{
		_Def_H[C]{v},
	}
}

func Make_Def_i[C comparable, D any](v [][]C) Def[C, D] {
	return Def[C, D]{
		_Def_I[C]{v},
	}
}

func Make_Def_m1[C comparable, D any](v customtypes.MapMap[string, int64]) Def[C, D] {
	return Def[C, D]{
		_Def_M1{v},
	}
}

func Make_Def_m2[C comparable, D any](v customtypes.MapMap[C, int64]) Def[C, D] {
	return Def[C, D]{
		_Def_M2[C]{v},
	}
}

func Make_Def_m3[C comparable, D any](v customtypes.MapMap[string, C]) Def[C, D] {
	return Def[C, D]{
		_Def_M3[C]{v},
	}
}

func Make_Def_m4[C comparable, D any](v customtypes.MapMap[C, D]) Def[C, D] {
	return Def[C, D]{
		_Def_M4[C, D]{v},
	}
}

func (un Def[C, D]) Cast_a() (C, bool) {
	br, ok := un.Branch.(_Def_A[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_b() ([]D, bool) {
	br, ok := un.Branch.(_Def_B[D])
	return br.V, ok
}

func (un Def[C, D]) Cast_c() (int64, bool) {
	br, ok := un.Branch.(_Def_C)
	return br.V, ok
}

func (un Def[C, D]) Cast_d() (Def[C, D], bool) {
	br, ok := un.Branch.(_Def_D[C, D])
	return br.V, ok
}

func (un Def[C, D]) Cast_e() (Abc[types.Either[string, int64], string], bool) {
	br, ok := un.Branch.(_Def_E)
	return br.V, ok
}

func (un Def[C, D]) Cast_f() ([]types.Either[string, types.Either[string, int64]], bool) {
	br, ok := un.Branch.(_Def_F)
	return br.V, ok
}

func (un Def[C, D]) Cast_f2() ([]types.Either[C, types.Either[string, int64]], bool) {
	br, ok := un.Branch.(_Def_F2[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g() (types.Either[[]string, types.Either[string, int64]], bool) {
	br, ok := un.Branch.(_Def_G)
	return br.V, ok
}

func (un Def[C, D]) Cast_g1() (types.Either[[]C, types.Either[C, C]], bool) {
	br, ok := un.Branch.(_Def_G1[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g2() (types.Either[*C, types.Either[C, C]], bool) {
	br, ok := un.Branch.(_Def_G2[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g3() (types.Either[map[string]C, types.Either[C, C]], bool) {
	br, ok := un.Branch.(_Def_G3[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g4() (types.Either[[]string, types.Either[C, C]], bool) {
	br, ok := un.Branch.(_Def_G4[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g5() (types.Either[types.Either[C, C], []string], bool) {
	br, ok := un.Branch.(_Def_G5[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g6() (types.Either[types.Either[string, string], []C], bool) {
	br, ok := un.Branch.(_Def_G6[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g7() (types.Either[types.Either[D, string], []C], bool) {
	br, ok := un.Branch.(_Def_G7[D, C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g8() (types.Either[[]C, []C], bool) {
	br, ok := un.Branch.(_Def_G8[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_g9() (types.Either[[]C, []D], bool) {
	br, ok := un.Branch.(_Def_G9[C, D])
	return br.V, ok
}

func (un Def[C, D]) Cast_g10() (types.Either[[]D, []C], bool) {
	br, ok := un.Branch.(_Def_G10[D, C])
	return br.V, ok
}

func (un Def[C, D]) Cast_h() ([]C, bool) {
	br, ok := un.Branch.(_Def_H[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_i() ([][]C, bool) {
	br, ok := un.Branch.(_Def_I[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_m1() (customtypes.MapMap[string, int64], bool) {
	br, ok := un.Branch.(_Def_M1)
	return br.V, ok
}

func (un Def[C, D]) Cast_m2() (customtypes.MapMap[C, int64], bool) {
	br, ok := un.Branch.(_Def_M2[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_m3() (customtypes.MapMap[string, C], bool) {
	br, ok := un.Branch.(_Def_M3[C])
	return br.V, ok
}

func (un Def[C, D]) Cast_m4() (customtypes.MapMap[C, D], bool) {
	br, ok := un.Branch.(_Def_M4[C, D])
	return br.V, ok
}

func Handle_Def[C comparable, D any, T any](
	_in Def[C, D],
	a func(a C) T,
	b func(b []D) T,
	c func(c int64) T,
	d func(d Def[C, D]) T,
	e func(e Abc[types.Either[string, int64], string]) T,
	f func(f []types.Either[string, types.Either[string, int64]]) T,
	f2 func(f2 []types.Either[C, types.Either[string, int64]]) T,
	g func(g types.Either[[]string, types.Either[string, int64]]) T,
	g1 func(g1 types.Either[[]C, types.Either[C, C]]) T,
	g2 func(g2 types.Either[*C, types.Either[C, C]]) T,
	g3 func(g3 types.Either[map[string]C, types.Either[C, C]]) T,
	g4 func(g4 types.Either[[]string, types.Either[C, C]]) T,
	g5 func(g5 types.Either[types.Either[C, C], []string]) T,
	g6 func(g6 types.Either[types.Either[string, string], []C]) T,
	g7 func(g7 types.Either[types.Either[D, string], []C]) T,
	g8 func(g8 types.Either[[]C, []C]) T,
	g9 func(g9 types.Either[[]C, []D]) T,
	g10 func(g10 types.Either[[]D, []C]) T,
	h func(h []C) T,
	i func(i [][]C) T,
	m1 func(m1 customtypes.MapMap[string, int64]) T,
	m2 func(m2 customtypes.MapMap[C, int64]) T,
	m3 func(m3 customtypes.MapMap[string, C]) T,
	m4 func(m4 customtypes.MapMap[C, D]) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Def_A[C]:
		if a != nil {
			return a(_b.V)
		}
	case _Def_B[D]:
		if b != nil {
			return b(_b.V)
		}
	case _Def_C:
		if c != nil {
			return c(_b.V)
		}
	case _Def_D[C, D]:
		if d != nil {
			return d(_b.V)
		}
	case _Def_E:
		if e != nil {
			return e(_b.V)
		}
	case _Def_F:
		if f != nil {
			return f(_b.V)
		}
	case _Def_F2[C]:
		if f2 != nil {
			return f2(_b.V)
		}
	case _Def_G:
		if g != nil {
			return g(_b.V)
		}
	case _Def_G1[C]:
		if g1 != nil {
			return g1(_b.V)
		}
	case _Def_G2[C]:
		if g2 != nil {
			return g2(_b.V)
		}
	case _Def_G3[C]:
		if g3 != nil {
			return g3(_b.V)
		}
	case _Def_G4[C]:
		if g4 != nil {
			return g4(_b.V)
		}
	case _Def_G5[C]:
		if g5 != nil {
			return g5(_b.V)
		}
	case _Def_G6[C]:
		if g6 != nil {
			return g6(_b.V)
		}
	case _Def_G7[D, C]:
		if g7 != nil {
			return g7(_b.V)
		}
	case _Def_G8[C]:
		if g8 != nil {
			return g8(_b.V)
		}
	case _Def_G9[C, D]:
		if g9 != nil {
			return g9(_b.V)
		}
	case _Def_G10[D, C]:
		if g10 != nil {
			return g10(_b.V)
		}
	case _Def_H[C]:
		if h != nil {
			return h(_b.V)
		}
	case _Def_I[C]:
		if i != nil {
			return i(_b.V)
		}
	case _Def_M1:
		if m1 != nil {
			return m1(_b.V)
		}
	case _Def_M2[C]:
		if m2 != nil {
			return m2(_b.V)
		}
	case _Def_M3[C]:
		if m3 != nil {
			return m3(_b.V)
		}
	case _Def_M4[C, D]:
		if m4 != nil {
			return m4(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Def")
}

func HandleWithErr_Def[C comparable, D any, T any](
	_in Def[C, D],
	a func(a C) (T, error),
	b func(b []D) (T, error),
	c func(c int64) (T, error),
	d func(d Def[C, D]) (T, error),
	e func(e Abc[types.Either[string, int64], string]) (T, error),
	f func(f []types.Either[string, types.Either[string, int64]]) (T, error),
	f2 func(f2 []types.Either[C, types.Either[string, int64]]) (T, error),
	g func(g types.Either[[]string, types.Either[string, int64]]) (T, error),
	g1 func(g1 types.Either[[]C, types.Either[C, C]]) (T, error),
	g2 func(g2 types.Either[*C, types.Either[C, C]]) (T, error),
	g3 func(g3 types.Either[map[string]C, types.Either[C, C]]) (T, error),
	g4 func(g4 types.Either[[]string, types.Either[C, C]]) (T, error),
	g5 func(g5 types.Either[types.Either[C, C], []string]) (T, error),
	g6 func(g6 types.Either[types.Either[string, string], []C]) (T, error),
	g7 func(g7 types.Either[types.Either[D, string], []C]) (T, error),
	g8 func(g8 types.Either[[]C, []C]) (T, error),
	g9 func(g9 types.Either[[]C, []D]) (T, error),
	g10 func(g10 types.Either[[]D, []C]) (T, error),
	h func(h []C) (T, error),
	i func(i [][]C) (T, error),
	m1 func(m1 customtypes.MapMap[string, int64]) (T, error),
	m2 func(m2 customtypes.MapMap[C, int64]) (T, error),
	m3 func(m3 customtypes.MapMap[string, C]) (T, error),
	m4 func(m4 customtypes.MapMap[C, D]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Def_A[C]:
		if a != nil {
			return a(_b.V)
		}
	case _Def_B[D]:
		if b != nil {
			return b(_b.V)
		}
	case _Def_C:
		if c != nil {
			return c(_b.V)
		}
	case _Def_D[C, D]:
		if d != nil {
			return d(_b.V)
		}
	case _Def_E:
		if e != nil {
			return e(_b.V)
		}
	case _Def_F:
		if f != nil {
			return f(_b.V)
		}
	case _Def_F2[C]:
		if f2 != nil {
			return f2(_b.V)
		}
	case _Def_G:
		if g != nil {
			return g(_b.V)
		}
	case _Def_G1[C]:
		if g1 != nil {
			return g1(_b.V)
		}
	case _Def_G2[C]:
		if g2 != nil {
			return g2(_b.V)
		}
	case _Def_G3[C]:
		if g3 != nil {
			return g3(_b.V)
		}
	case _Def_G4[C]:
		if g4 != nil {
			return g4(_b.V)
		}
	case _Def_G5[C]:
		if g5 != nil {
			return g5(_b.V)
		}
	case _Def_G6[C]:
		if g6 != nil {
			return g6(_b.V)
		}
	case _Def_G7[D, C]:
		if g7 != nil {
			return g7(_b.V)
		}
	case _Def_G8[C]:
		if g8 != nil {
			return g8(_b.V)
		}
	case _Def_G9[C, D]:
		if g9 != nil {
			return g9(_b.V)
		}
	case _Def_G10[D, C]:
		if g10 != nil {
			return g10(_b.V)
		}
	case _Def_H[C]:
		if h != nil {
			return h(_b.V)
		}
	case _Def_I[C]:
		if i != nil {
			return i(_b.V)
		}
	case _Def_M1:
		if m1 != nil {
			return m1(_b.V)
		}
	case _Def_M2[C]:
		if m2 != nil {
			return m2(_b.V)
		}
	case _Def_M3[C]:
		if m3 != nil {
			return m3(_b.V)
		}
	case _Def_M4[C, D]:
		if m4 != nil {
			return m4(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Def")
}

type Zyx[Z comparable, Y any] struct {
	_Zyx[Z, Y]
}

type _Zyx[Z comparable, Y any] struct {
	A  Abc[Z, Y]                                           `json:"a"`
	E  Abc[types.Either[string, int64], string]            `json:"e"`
	F  []types.Either[string, types.Either[string, int64]] `json:"f"`
	F1 []types.Either[Z, types.Either[Z, int64]]           `json:"f1"`
	F2 []types.Either[Z, types.Either[Z, Z]]               `json:"f2"`
	F3 []types.Either[string, types.Either[Z, Y]]          `json:"f3"`
	G  types.Either[[]string, types.Either[string, int64]] `json:"g"`
}

func MakeAll_Zyx[Z comparable, Y any](
	a Abc[Z, Y],
	e Abc[types.Either[string, int64], string],
	f []types.Either[string, types.Either[string, int64]],
	f1 []types.Either[Z, types.Either[Z, int64]],
	f2 []types.Either[Z, types.Either[Z, Z]],
	f3 []types.Either[string, types.Either[Z, Y]],
	g types.Either[[]string, types.Either[string, int64]],
) Zyx[Z, Y] {
	return Zyx[Z, Y]{
		_Zyx[Z, Y]{
			A:  a,
			E:  e,
			F:  f,
			F1: f1,
			F2: f2,
			F3: f3,
			G:  g,
		},
	}
}

func Make_Zyx[Z comparable, Y any](
	a Abc[Z, Y],
	e Abc[types.Either[string, int64], string],
	f []types.Either[string, types.Either[string, int64]],
	f1 []types.Either[Z, types.Either[Z, int64]],
	f2 []types.Either[Z, types.Either[Z, Z]],
	f3 []types.Either[string, types.Either[Z, Y]],
	g types.Either[[]string, types.Either[string, int64]],
) Zyx[Z, Y] {
	ret := Zyx[Z, Y]{
		_Zyx[Z, Y]{
			A:  a,
			E:  e,
			F:  f,
			F1: f1,
			F2: f2,
			F3: f3,
			G:  g,
		},
	}
	return ret
}
