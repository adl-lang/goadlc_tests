// Code generated by goadlc v3 - DO NOT EDIT.
package generics

import (
	"fmt"
	goadl "github.com/adl-lang/goadl_rt/v3"
)

type Abc[A any, B any] struct {
	_Abc[A, B]
}

type _Abc[A any, B any] struct {
	A               A                             `json:"a"`
	B               []B                           `json:"b"`
	Kids            []Abc[A, B]                   `json:"kids"`
	Grandkids_named map[string]Abc[int64, string] `json:"grandkids_named"`
	C               int64                         `json:"c"`
	D               Def[A, B]                     `json:"d"`
	E               Def[int64, string]            `json:"e"`
	F               *Abc[int64, string]           `json:"f"`
}

func MakeAll_Abc[A any, B any](
	a A,
	b []B,
	kids []Abc[A, B],
	grandkids_named map[string]Abc[int64, string],
	c int64,
	d Def[A, B],
	e Def[int64, string],
	f *Abc[int64, string],
) Abc[A, B] {
	return Abc[A, B]{
		_Abc[A, B]{
			A:               a,
			B:               b,
			Kids:            kids,
			Grandkids_named: grandkids_named,
			C:               c,
			D:               d,
			E:               e,
			F:               f,
		},
	}
}

func Make_Abc[A any, B any](
	a A,
	b []B,
	d Def[A, B],
) Abc[A, B] {
	ret := Abc[A, B]{
		_Abc[A, B]{
			A:               a,
			B:               b,
			Kids:            ((*Abc[A, B])(nil)).Default_kids(),
			Grandkids_named: ((*Abc[A, B])(nil)).Default_grandkids_named(),
			C:               ((*Abc[A, B])(nil)).Default_c(),
			D:               d,
			E:               ((*Abc[A, B])(nil)).Default_e(),
			F:               ((*Abc[A, B])(nil)).Default_f(),
		},
	}
	return ret
}

func (*Abc[A, B]) Default_kids() []Abc[A, B] {
	return []Abc[A, B]{}
}
func (*Abc[A, B]) Default_grandkids_named() map[string]Abc[int64, string] {
	return map[string]Abc[int64, string]{
		"fav": MakeAll_Abc[int64, string](
			4321,
			[]string{
				"aaa",
			},
			[]Abc[int64, string]{},
			map[string]Abc[int64, string]{},
			99,
			Make_Def_d[int64, string](
				Make_Def_a[int64, string](
					22,
				),
			),
			Make_Def_a[int64, string](
				1234,
			),
			nil,
		),
	}
}
func (*Abc[A, B]) Default_c() int64 {
	return 66
}
func (*Abc[A, B]) Default_e() Def[int64, string] {
	return Make_Def_a[int64, string](
		1234,
	)
}
func (*Abc[A, B]) Default_f() *Abc[int64, string] {
	return goadl.Addr(MakeAll_Abc[int64, string](
		4321,
		[]string{
			"aaa",
		},
		[]Abc[int64, string]{},
		map[string]Abc[int64, string]{
			"fav": MakeAll_Abc[int64, string](
				4321,
				[]string{
					"aaa",
				},
				[]Abc[int64, string]{},
				map[string]Abc[int64, string]{},
				99,
				Make_Def_d[int64, string](
					Make_Def_a[int64, string](
						22,
					),
				),
				Make_Def_a[int64, string](
					1234,
				),
				nil,
			),
		},
		99,
		Make_Def_d[int64, string](
			Make_Def_a[int64, string](
				22,
			),
		),
		Make_Def_a[int64, string](
			1234,
		),
		nil,
	))
}

type Def[A any, B any] struct {
	Branch DefBranch[A, B]
}

type DefBranch[A any, B any] interface {
	isDefBranch()
}

func (*Def[A, B]) MakeNewBranch(key string) (any, error) {
	switch key {
	case "a":
		return &_Def_A[A]{}, nil
	case "b":
		return &_Def_B[B]{}, nil
	case "c":
		return &_Def_C{}, nil
	case "d":
		return &_Def_D[A, B]{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _Def_A[A any] struct {
	V A `branch:"a"`
}
type _Def_B[B any] struct {
	V []B `branch:"b"`
}
type _Def_C struct {
	V int64 `branch:"c"`
}
type _Def_D[A any, B any] struct {
	V Def[A, B] `branch:"d"`
}

func (_Def_A[A]) isDefBranch()    {}
func (_Def_B[B]) isDefBranch()    {}
func (_Def_C) isDefBranch()       {}
func (_Def_D[A, B]) isDefBranch() {}

func Make_Def_a[A any, B any](v A) Def[A, B] {
	return Def[A, B]{
		_Def_A[A]{v},
	}
}

func Make_Def_b[A any, B any](v []B) Def[A, B] {
	return Def[A, B]{
		_Def_B[B]{v},
	}
}

func Make_Def_c[A any, B any](v int64) Def[A, B] {
	return Def[A, B]{
		_Def_C{v},
	}
}

func Make_Def_d[A any, B any](v Def[A, B]) Def[A, B] {
	return Def[A, B]{
		_Def_D[A, B]{v},
	}
}

func (un Def[A, B]) Cast_a() (A, bool) {
	br, ok := un.Branch.(_Def_A[A])
	return br.V, ok
}

func (un Def[A, B]) Cast_b() ([]B, bool) {
	br, ok := un.Branch.(_Def_B[B])
	return br.V, ok
}

func (un Def[A, B]) Cast_c() (int64, bool) {
	br, ok := un.Branch.(_Def_C)
	return br.V, ok
}

func (un Def[A, B]) Cast_d() (Def[A, B], bool) {
	br, ok := un.Branch.(_Def_D[A, B])
	return br.V, ok
}

func Handle_Def[A any, B any, T any](
	_in Def[A, B],
	a func(a A) T,
	b func(b []B) T,
	c func(c int64) T,
	d func(d Def[A, B]) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _Def_A[A]:
		if a != nil {
			return a(_b.V)
		}
	case _Def_B[B]:
		if b != nil {
			return b(_b.V)
		}
	case _Def_C:
		if c != nil {
			return c(_b.V)
		}
	case _Def_D[A, B]:
		if d != nil {
			return d(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Def")
}

func HandleWithErr_Def[A any, B any, T any](
	_in Def[A, B],
	a func(a A) (T, error),
	b func(b []B) (T, error),
	c func(c int64) (T, error),
	d func(d Def[A, B]) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _Def_A[A]:
		if a != nil {
			return a(_b.V)
		}
	case _Def_B[B]:
		if b != nil {
			return b(_b.V)
		}
	case _Def_C:
		if c != nil {
			return c(_b.V)
		}
	case _Def_D[A, B]:
		if d != nil {
			return d(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : Def")
}
